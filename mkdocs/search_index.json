{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "一. 介绍"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/organization/workspace/", 
            "text": "简介\n\n\n\n\n用于放置一个go程序员的所有go代码和依赖在一个workspace里。\n\n\n\n\n前提是生成出的二进制文件不重名，如果存在重名情况，就要分成不同的workspace）\n\n\n\n\nworkspace、repository、package\n\n\n\n\nworkspace：包含多个版本控制的repository\n\n    repository：包含多个package\n\n        package：包含多个go源码文件\n\n\n\n\n标准的workspace本地目录结构\n\n\n\n\nsrc：go源码文件\n\n\npkg：package object（编译出的二进制文件）\n\n\nbin：可执行文件（编译出的二进制文件）", 
            "title": "1. workspace"
        }, 
        {
            "location": "/organization/workspace/#_1", 
            "text": "用于放置一个go程序员的所有go代码和依赖在一个workspace里。   前提是生成出的二进制文件不重名，如果存在重名情况，就要分成不同的workspace）", 
            "title": "简介"
        }, 
        {
            "location": "/organization/workspace/#workspacerepositorypackage", 
            "text": "workspace：包含多个版本控制的repository\n\n    repository：包含多个package\n\n        package：包含多个go源码文件", 
            "title": "workspace、repository、package"
        }, 
        {
            "location": "/organization/workspace/#workspace", 
            "text": "src：go源码文件  pkg：package object（编译出的二进制文件）  bin：可执行文件（编译出的二进制文件）", 
            "title": "标准的workspace本地目录结构"
        }, 
        {
            "location": "/organization/gopath/", 
            "text": "简介\n\n\n\n\nGOPATH：workspace的路径，默认为\n$HOME/go\n。\n\n\n\n\nGOPATH不是指go安装路径，因此不能写/usr/local/go-1.8之类的\n\n\n\n\n如何查看GOPATH\n\n\n\n\ngo env\n可以看到所有go环境变量，如果只看GOPATH可以\ngo env GOPATH\n\n\nGOPATH的设置\n\n\n\n\n执行命令\n\n\nexport GOPATH=/path/to\n\n\n\n\n为便于在命令行下执行编译出的二进制可执行程序，建议将bin目录路径加到系统PATH上:\n\n\nexport PATH=$PATH:$(go env GOPATH)/bin\n\n\n\n\n另外，可以将上面2个export写入~/.bash_profile，然后\nsource ~/.bash_profile\n 立即生效", 
            "title": "2. GOPATH"
        }, 
        {
            "location": "/organization/gopath/#_1", 
            "text": "GOPATH：workspace的路径，默认为 $HOME/go 。   GOPATH不是指go安装路径，因此不能写/usr/local/go-1.8之类的", 
            "title": "简介"
        }, 
        {
            "location": "/organization/gopath/#gopath", 
            "text": "go env 可以看到所有go环境变量，如果只看GOPATH可以 go env GOPATH", 
            "title": "如何查看GOPATH"
        }, 
        {
            "location": "/organization/gopath/#gopath_1", 
            "text": "执行命令  export GOPATH=/path/to  为便于在命令行下执行编译出的二进制可执行程序，建议将bin目录路径加到系统PATH上:  export PATH=$PATH:$(go env GOPATH)/bin  另外，可以将上面2个export写入~/.bash_profile，然后 source ~/.bash_profile  立即生效", 
            "title": "GOPATH的设置"
        }, 
        {
            "location": "/organization/importpath/", 
            "text": "简介\n\n\n\n\n一个import path（包路径）唯一标识一个package，一个package的import path相当于他所处于workspace中的相对路径。\n\n\n导入路径可以是本地也可以是在远程，比如开源代码通常放在github.com。当编译时候会自动将远程文件载到本地目录上进行读取\n\n\n组成\n\n\n\n\nimport path由base path和package path组成\n\n\nbase path指repository路径，比如\ngithub.com/cyent/golang/example\n（对应本地workspace中的路径\n$GOPATH/src/github.com/cyent/golang/example\n）\n\n\npackage path指具体包的路径，比如有个hello包，那么其import path就是github.com/cyent/golang/example/hello\n\n\n\n\ngithub.com也有类似workspace的概念，叫做Organizations\n\n\n比如在github上注册了一个账户叫做cyent（账户主页:\ngithub.com/cyent\n），之后创建的repo都可以放在这下面，比如\ngithub.com/cyent/golang\n\n\n通常个人用户会像上面这么用，但是对于团队或者公司来说，cyent只是一个注册账号，不作为品牌推广，因此会用团队名，公司名，或产品系列名等，比如\ngithub.com/mycompany\n，这就是建立了一个organization，organization名字叫做mycompany，之后repo都放在这下面，比如\ngithub.com/mycompany/myproduct\n\n\n\n\n例子\n\n\n\n\n举例说明：假设\nGOPATH=/opt/cyent/golang\n，那么本地目录结构:\n\n\n/opt/cyent/golang/src/\n    github.com/organization1/repo\n    github.com/organization2/repo\n    github.com/cyent/golang\n\n\n\n\n上面这种目录结构解读：\n\n/opt/cyent/golang\n是放置我的所有go代码的根路径\n\n\n其中我自己的代码在\n/opt/cyent/golang/src/github.com/cyent/golang\n下\n\n\norganization1/repo\n和\norganization2/repo\n是我代码中会依赖的库（编译时候会自动载到本地来）", 
            "title": "3. import path"
        }, 
        {
            "location": "/organization/importpath/#_1", 
            "text": "一个import path（包路径）唯一标识一个package，一个package的import path相当于他所处于workspace中的相对路径。  导入路径可以是本地也可以是在远程，比如开源代码通常放在github.com。当编译时候会自动将远程文件载到本地目录上进行读取", 
            "title": "简介"
        }, 
        {
            "location": "/organization/importpath/#_2", 
            "text": "import path由base path和package path组成  base path指repository路径，比如 github.com/cyent/golang/example （对应本地workspace中的路径 $GOPATH/src/github.com/cyent/golang/example ）  package path指具体包的路径，比如有个hello包，那么其import path就是github.com/cyent/golang/example/hello   github.com也有类似workspace的概念，叫做Organizations  比如在github上注册了一个账户叫做cyent（账户主页: github.com/cyent ），之后创建的repo都可以放在这下面，比如 github.com/cyent/golang  通常个人用户会像上面这么用，但是对于团队或者公司来说，cyent只是一个注册账号，不作为品牌推广，因此会用团队名，公司名，或产品系列名等，比如 github.com/mycompany ，这就是建立了一个organization，organization名字叫做mycompany，之后repo都放在这下面，比如 github.com/mycompany/myproduct", 
            "title": "组成"
        }, 
        {
            "location": "/organization/importpath/#_3", 
            "text": "举例说明：假设 GOPATH=/opt/cyent/golang ，那么本地目录结构:  /opt/cyent/golang/src/\n    github.com/organization1/repo\n    github.com/organization2/repo\n    github.com/cyent/golang  上面这种目录结构解读： /opt/cyent/golang 是放置我的所有go代码的根路径  其中我自己的代码在 /opt/cyent/golang/src/github.com/cyent/golang 下  organization1/repo 和 organization2/repo 是我代码中会依赖的库（编译时候会自动载到本地来）", 
            "title": "例子"
        }, 
        {
            "location": "/organization/helloworld/", 
            "text": "程序入口main.main\n\n\n\n\npackage\n \nmain\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\nhello, world\n\n\n\n\n在一个package里创建一个\nxxx.go\n，比如在\n$GOPATH/src/github.com/cyent/golang/example/hello\n里创建了一个myfirst.go（也可以叫其他文件名，重点是该文件里包含着main.main），里面写着：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nHello, world!\n)\n\n\n}\n\n\n\n\n\n然后在任意目录下执行\n\ngo install github.com/cyent/golang/example/hello\n\n\n\n就会编译出可执行的二进制程序并自动放入\n$GOPATH/bin\n中，比如这个例子中生成的程序就是\n$GOPATH/bin/hello\n\n\n\n\n注意生成的二进制文件名\n\n\n可以看出来，生成的二进制文件名是根据package名自动生成的（即目录名: hello），和文件名myfirst.go毫无关系\n\n\n\n\n\n\ngo的规范是目录名和文件名一致\n\n\n通常是\n$GOPATH/src/github.com/cyent/golang/example/hello/hello.go\n，这样比较符合习惯，也是go的编码规范\n\n\n\n\n执行\n\n\n$GOPATH/bin/hello\n\n\n\n\n\n\n如果有将\n$GOPATH/bin\n加入到$PATH里，那么这里直接执行hello即可\n\n\n\n\n效果\n\n\nHello, world!\n\n\n\n\n执行\ngo install\n还可以在package目录下执行，这样就不用跟package路径了。比如在\n$GOPATH/src/github.com/cyent/golang/example/hello\n目录下直接执行\ngo install\n即可\n\n\n附: 此时GOPATH目录结构\n\n\n\n\n.\n├── bin\n│   └── hello\n├── pkg\n└── src\n    └── github.com\n        └── cyent\n            └── golang\n                └── example\n                    └── hello\n                        └── hello.go", 
            "title": "4. hello world"
        }, 
        {
            "location": "/organization/helloworld/#mainmain", 
            "text": "package   main  func   main ()   { \n     ...  }", 
            "title": "程序入口main.main"
        }, 
        {
            "location": "/organization/helloworld/#hello-world", 
            "text": "在一个package里创建一个 xxx.go ，比如在 $GOPATH/src/github.com/cyent/golang/example/hello 里创建了一个myfirst.go（也可以叫其他文件名，重点是该文件里包含着main.main），里面写着：  package   main  import   fmt  func   main ()   { \n     fmt . Println ( Hello, world! )  }   然后在任意目录下执行 go install github.com/cyent/golang/example/hello  就会编译出可执行的二进制程序并自动放入 $GOPATH/bin 中，比如这个例子中生成的程序就是 $GOPATH/bin/hello   注意生成的二进制文件名  可以看出来，生成的二进制文件名是根据package名自动生成的（即目录名: hello），和文件名myfirst.go毫无关系    go的规范是目录名和文件名一致  通常是 $GOPATH/src/github.com/cyent/golang/example/hello/hello.go ，这样比较符合习惯，也是go的编码规范   执行  $GOPATH/bin/hello   如果有将 $GOPATH/bin 加入到$PATH里，那么这里直接执行hello即可   效果  Hello, world!  执行 go install 还可以在package目录下执行，这样就不用跟package路径了。比如在 $GOPATH/src/github.com/cyent/golang/example/hello 目录下直接执行 go install 即可", 
            "title": "hello, world"
        }, 
        {
            "location": "/organization/helloworld/#gopath", 
            "text": ".\n├── bin\n│   └── hello\n├── pkg\n└── src\n    └── github.com\n        └── cyent\n            └── golang\n                └── example\n                    └── hello\n                        └── hello.go", 
            "title": "附: 此时GOPATH目录结构"
        }, 
        {
            "location": "/organization/firstlib/", 
            "text": "创建lib\n\n\n\n\n创建\n$GOPATH/src/github.com/cyent/golang/example/stringutil\n目录，并在目录里放置reverse.go，内容如下\n\n\n// Package stringutil contains utility functions for working with strings.\n\n\npackage\n \nstringutil\n\n\n\n// Reverse returns its argument string reversed rune-wise left to right.\n\n\nfunc\n \nReverse\n(\ns\n \nstring\n)\n \nstring\n \n{\n\n    \nr\n \n:=\n \n[]\nrune\n(\ns\n)\n\n    \nfor\n \ni\n,\n \nj\n \n:=\n \n0\n,\n \nlen\n(\nr\n)\n-\n1\n;\n \ni\n \n \nlen\n(\nr\n)\n/\n2\n;\n \ni\n,\n \nj\n \n=\n \ni\n+\n1\n,\n \nj\n-\n1\n \n{\n\n        \nr\n[\ni\n],\n \nr\n[\nj\n]\n \n=\n \nr\n[\nj\n],\n \nr\n[\ni\n]\n\n    \n}\n\n    \nreturn\n \nstring\n(\nr\n)\n\n\n}\n\n\n\n\n\ngo install github.com/cyent/golang/example/stringutil\n\n\n\n\n会看到生成了\n$GOPATH/pkg/darwin_amd64/github.com/cyent/golang/example/stringutil.a\n\n\n\n\n注意这里的路径\n\n\n路径不是\ncyent/golang/example/stringutil/stringutil.a\n，而是\ncyent/golang/example/stringutil.a\n。\n\n\n上面\nreverse.go\n里的代码也可以除了放在\n$GOPATH/src/github.com/cyent/golang/example/stringutil/reverse.go\n，也可以放在\n$GOPATH/src/github.com/cyent/golang/example/stringutil.go\n。实际效果是一样的。\n\n\n用stringutil目录只是为了分隔代码，这样比较容易让人理解，而且如果stringutil包里的函数比较多的时候，就需要分成多个源码文件，用文件名来标识内容，提高可读性，比如函数名叫做Reverse，文件名就叫做reverse.go。如果所有函数都放在一个代码文件里，那么这个代码文件就太庞大，显得很乱，不利于维护\n\n\n\n\n调用lib\n\n\n修改\n上一页\n中的\nhello.go\n，改为：\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \ngithub.com/cyent/golang/example/stringutil\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nstringutil\n.\nReverse\n(\n!oG ,olleH\n))\n\n\n}\n\n\n\n\n\n执行\n\n\ngo install github.com/cyent/golang/example/hello\n\n\n\n\n就会编译出可执行的二进制程序并自动放入\n$GOPATH/bin\n中，比如这个例子中生成的程序就是\n$GOPATH/bin/hello\n\n\n执行\n\n\n$GOPATH/bin/hello\n\n\n\n\n效果\n\n\nHello, Go!\n\n\n\n\n\n\n注意生成的二进制路径\n\n\n这个hello二进制文件生成路径是\n$GOPATH/bin/hello\n，而不是\n$GOPATH/bin/github.com/cyent/golang/example/hello\n，说明一个workspace生成的二进制文件都在一起\n\n\n一个workspace里可执行程序名不能相同，因为都是放在bin目录下，这目录下没有任何子目录。即不能存在这样2个main package在一个workspace里：（假设下面2个hello.go都是package main）\n$GOPATH/src/github.com/cyent/example/repo1/hello.go\n$GOPATH/src/github.com/cyent/example/repo2/hello.go\n\n\n\n\n\n\n自动搜索所有函数并集中到一个.a文件\n\n\n生成library时候是会自动把\n$GOPATH/src/github.com/cyent/golang/example/stringutil/\n下面所有.go文件里包含的函数集中到\nstringutil.a\n中（根据这些.go文件中的package xxx来自动加入到一个.a），因此如果存在相同的函数，会报错提示重复\n\n\n\n\n\n\n$GOPATH/pkg路径\n\n\n注意\ngo install\n会将\nstringutil.a\n对象放到\npkg/darwin_amd64\n目录中，它会反映出其源码目录。 这就是在此之后调用go工具，能找到包对象并避免不必要的重新编译的原因。darwin_amd64这部分能帮助跨平台编译，并反映出你的操作系统和架构。\n\n\n\n\n\n\n静态链接\n\n\nGo的可执行命令是静态链接的；在运行生成的可执行二进制程序时，包对象\nstringutil.a\n无需存在。\n\n\n\n\n\n\ngo源码文件第一行必须是package name\n\n\npackage name就是调用时候import中/最后一段，比如想别的程序通过import \"crypto/rot13\"调用，那么就写package rot13\n\n\n生成可执行程序，package必须为main\n\n\n\n\n附: 此时GOPATH目录结构\n\n\n\n\n.\n├── bin\n│   └── hello\n├── pkg\n│   └── darwin_amd64\n│       └── github.com\n│           └── cyent\n│               └── golang\n│                   └── example\n│                       └── stringutil.a\n└── src\n    └── github.com\n        └── cyent\n            └── golang\n                └── example\n                    ├── hello\n                    │   └── hello.go\n                    └── stringutil\n                        └── reverse.go", 
            "title": "5. 第一个library"
        }, 
        {
            "location": "/organization/firstlib/#lib", 
            "text": "创建 $GOPATH/src/github.com/cyent/golang/example/stringutil 目录，并在目录里放置reverse.go，内容如下  // Package stringutil contains utility functions for working with strings.  package   stringutil  // Reverse returns its argument string reversed rune-wise left to right.  func   Reverse ( s   string )   string   { \n     r   :=   [] rune ( s ) \n     for   i ,   j   :=   0 ,   len ( r ) - 1 ;   i     len ( r ) / 2 ;   i ,   j   =   i + 1 ,   j - 1   { \n         r [ i ],   r [ j ]   =   r [ j ],   r [ i ] \n     } \n     return   string ( r )  }   go install github.com/cyent/golang/example/stringutil  会看到生成了 $GOPATH/pkg/darwin_amd64/github.com/cyent/golang/example/stringutil.a   注意这里的路径  路径不是 cyent/golang/example/stringutil/stringutil.a ，而是 cyent/golang/example/stringutil.a 。  上面 reverse.go 里的代码也可以除了放在 $GOPATH/src/github.com/cyent/golang/example/stringutil/reverse.go ，也可以放在 $GOPATH/src/github.com/cyent/golang/example/stringutil.go 。实际效果是一样的。  用stringutil目录只是为了分隔代码，这样比较容易让人理解，而且如果stringutil包里的函数比较多的时候，就需要分成多个源码文件，用文件名来标识内容，提高可读性，比如函数名叫做Reverse，文件名就叫做reverse.go。如果所有函数都放在一个代码文件里，那么这个代码文件就太庞大，显得很乱，不利于维护", 
            "title": "创建lib"
        }, 
        {
            "location": "/organization/firstlib/#lib_1", 
            "text": "修改 上一页 中的 hello.go ，改为：  package   main  import   ( \n     fmt \n     github.com/cyent/golang/example/stringutil  )  func   main ()   { \n     fmt . Println ( stringutil . Reverse ( !oG ,olleH ))  }   执行  go install github.com/cyent/golang/example/hello  就会编译出可执行的二进制程序并自动放入 $GOPATH/bin 中，比如这个例子中生成的程序就是 $GOPATH/bin/hello  执行  $GOPATH/bin/hello  效果  Hello, Go!   注意生成的二进制路径  这个hello二进制文件生成路径是 $GOPATH/bin/hello ，而不是 $GOPATH/bin/github.com/cyent/golang/example/hello ，说明一个workspace生成的二进制文件都在一起  一个workspace里可执行程序名不能相同，因为都是放在bin目录下，这目录下没有任何子目录。即不能存在这样2个main package在一个workspace里：（假设下面2个hello.go都是package main）\n$GOPATH/src/github.com/cyent/example/repo1/hello.go\n$GOPATH/src/github.com/cyent/example/repo2/hello.go    自动搜索所有函数并集中到一个.a文件  生成library时候是会自动把 $GOPATH/src/github.com/cyent/golang/example/stringutil/ 下面所有.go文件里包含的函数集中到 stringutil.a 中（根据这些.go文件中的package xxx来自动加入到一个.a），因此如果存在相同的函数，会报错提示重复    $GOPATH/pkg路径  注意 go install 会将 stringutil.a 对象放到 pkg/darwin_amd64 目录中，它会反映出其源码目录。 这就是在此之后调用go工具，能找到包对象并避免不必要的重新编译的原因。darwin_amd64这部分能帮助跨平台编译，并反映出你的操作系统和架构。    静态链接  Go的可执行命令是静态链接的；在运行生成的可执行二进制程序时，包对象 stringutil.a 无需存在。    go源码文件第一行必须是package name  package name就是调用时候import中/最后一段，比如想别的程序通过import \"crypto/rot13\"调用，那么就写package rot13  生成可执行程序，package必须为main", 
            "title": "调用lib"
        }, 
        {
            "location": "/organization/firstlib/#gopath", 
            "text": ".\n├── bin\n│   └── hello\n├── pkg\n│   └── darwin_amd64\n│       └── github.com\n│           └── cyent\n│               └── golang\n│                   └── example\n│                       └── stringutil.a\n└── src\n    └── github.com\n        └── cyent\n            └── golang\n                └── example\n                    ├── hello\n                    │   └── hello.go\n                    └── stringutil\n                        └── reverse.go", 
            "title": "附: 此时GOPATH目录结构"
        }, 
        {
            "location": "/organization/test/", 
            "text": "内置的testing模块\n\n\n\n\ngo内置一个轻量级测试框架，使用方法：\n\n\n\n\n\n\n文件以\n_test.go\n结尾\n\n\n\n\n\n\nimport \ntesting\n\n\n\n\n\n\n函数名为\nTestXXX\n，并且parameter为\nt *testing.T\n\n\n\n\n\n\n例子：\n\n\n在\n$GOPATH/src/github.com/cyent/golang/example/stringutil\n里新建文件\nreverse_test.go\n\n\npackage\n \nstringutil\n\n\n\nimport\n \ntesting\n\n\n\nfunc\n \nTestReverse\n(\nt\n \n*\ntesting\n.\nT\n)\n \n{\n\n    \ncases\n \n:=\n \n[]\nstruct\n \n{\n\n        \nin\n,\n \nwant\n \nstring\n\n    \n}{\n\n        \n{\nHello, world\n,\n \ndlrow ,olleH\n},\n\n        \n{\nHello, 世界\n,\n \n界世 ,olleH\n},\n\n        \n{\n,\n \n},\n\n    \n}\n\n    \nfor\n \n_\n,\n \nc\n \n:=\n \nrange\n \ncases\n \n{\n\n        \ngot\n \n:=\n \nReverse\n(\nc\n.\nin\n)\n\n        \nif\n \ngot\n \n!=\n \nc\n.\nwant\n \n{\n\n            \nt\n.\nErrorf\n(\nReverse(%q) == %q, want %q\n,\n \nc\n.\nin\n,\n \ngot\n,\n \nc\n.\nwant\n)\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n执行测试：\n\n\ngo test github.com/cyent/golang/exmaple/stringutil\n\n\n\n\n或者在\n$GOPATH/src/github.com/cyent/golang/exmaple/stringutil\n目录下执行\ngo test\n\n\n输出\n\n\nok      github.com/cyent/golang/example/stringutil  0.006s\n\n\n\n\n表示测试通过\n\n\n如果是在stringutil目录下直接执行\ngo test\n，会输出\n\n\nPASS\nok      github.com/cyent/golang/example/stringutil  0.005s\n\n\n\n\n\n\n推荐使用\ngo test -v\n，输出更详细\n\n\n\n\n我对单元测试的理解\n\n\n\n\n我也是第一次接触单元测试，所以我的理解也许不是对的\n\n\n首先，我是在百度百科里看到的\n单元测试\n，其中有几段话受益匪浅:\n\n\n\n\n什么时候测试？单元测试越早越好，早到什么程度？极限编程(Extreme Programming,或简称XP)讲究TDD，即测试驱动开发，先编写测试代码，再进行开发。在实际的工作中，可以不必过分强调先什么后什么，重要的是高效和感觉舒适。从经验来看，\n先编写产品函数的框架，然后编写测试函数，针对产品函数的功能编写测试用例，然后编写产品函数的代码，每写一个功能点都运行测试，随时补充测试用例\n。所谓先编写产品函数的框架，是指先编写函数空的实现，有返回值的直接返回一个合适值，编译通过后再编写测试代码，这时，函数名、参数表、返回类型都应该确定下来了，所编写的测试代码以后需修改的可能性比较小。\n\n\n这是那些没有首先为每个单元编写一个详细的规格说明而直接跳到编码阶段的开发人员提出的一条普遍的抱怨，\n当编码完成以后并且面临代码测试任务的时候，他们就阅读这些代码并找出它实际上做了什么，把他们的测试工作基于已经写好的代码的基础上\n。当然，他们无法证明任何事情。所有的这些测试工作能够表明的事情就是编译器工作正常。是的，他们也许能够抓住（希望能够）罕见的编译器Bug，但是他们能够做的仅仅是这些。\n如果他们首先写好一个详细的规格说明，测试能够以规格说明为基础。代码就能够针对它的规格说明，而不是针对自身进行测试。这样的测试仍然能够抓住编译器的Bug，同时也能找到更多的编码错误，甚至是一些规格说明中的错误。\n好的规格说明可以使测试的质量更高，所以最后的结论是高质量的测试需要高质量的规格说明\n。\n\n\n在实践中会出现这样的情况：一个开发人员要面对测试一个单元时只给出单元的代码而没有规格说明这样吃力不讨好的任务。你怎样做才会有更多的收获，而不仅仅是发现编译器的Bug？\n第一步是理解这个单元原本要做什么， --- 不是它实际上做了什么\n。比较有效的方法是倒推出一个概要的规格说明。这个过程的主要输入条件是要阅读那些程序代码和注释， 主要针对这个单元， 及调用它和被它调用的相关代码。\n画出流程图是非常有帮助的\n，你可以用手工或使用某种工具。\n可以组织对这个概要规格说明的走读（Review)，以确保对这个单元的说明没有基本的错误， 有了这种最小程度的代码深层说明，就可以用它来设计单元测试了\n。\n\n\n\n\ngo test\n时候会先编译检查一遍，和\ngo run\n、\ngo install\n相同，即只有编译检查通过了才会继续。因此\ngo test\n实际上做了2个测试: 传入参数和数量是否正确（不正确就编译报错），以及业务逻辑是否正确。\n\n\n关于业务逻辑是否正确，我的理解是：假设被测试函数是做除法，在函数里的逻辑会判断传入的参数是否为0，如果为0，则返回error。那么测试内容就是传入0，看下是否返回error，如果没有返回error，则t.Errorf抛错\n\n\n总结: 编写单元测试时候，根据预设规则，调用被测试函数，依次传入预设的若干情况，来测试函数的返回是否正确。", 
            "title": "6. 内置的轻量级测试框架"
        }, 
        {
            "location": "/organization/test/#testing", 
            "text": "go内置一个轻量级测试框架，使用方法：    文件以 _test.go 结尾    import  testing    函数名为 TestXXX ，并且parameter为 t *testing.T    例子：  在 $GOPATH/src/github.com/cyent/golang/example/stringutil 里新建文件 reverse_test.go  package   stringutil  import   testing  func   TestReverse ( t   * testing . T )   { \n     cases   :=   [] struct   { \n         in ,   want   string \n     }{ \n         { Hello, world ,   dlrow ,olleH }, \n         { Hello, 世界 ,   界世 ,olleH }, \n         { ,   }, \n     } \n     for   _ ,   c   :=   range   cases   { \n         got   :=   Reverse ( c . in ) \n         if   got   !=   c . want   { \n             t . Errorf ( Reverse(%q) == %q, want %q ,   c . in ,   got ,   c . want ) \n         } \n     }  }   执行测试：  go test github.com/cyent/golang/exmaple/stringutil  或者在 $GOPATH/src/github.com/cyent/golang/exmaple/stringutil 目录下执行 go test  输出  ok      github.com/cyent/golang/example/stringutil  0.006s  表示测试通过  如果是在stringutil目录下直接执行 go test ，会输出  PASS\nok      github.com/cyent/golang/example/stringutil  0.005s   推荐使用 go test -v ，输出更详细", 
            "title": "内置的testing模块"
        }, 
        {
            "location": "/organization/test/#_1", 
            "text": "我也是第一次接触单元测试，所以我的理解也许不是对的  首先，我是在百度百科里看到的 单元测试 ，其中有几段话受益匪浅:   什么时候测试？单元测试越早越好，早到什么程度？极限编程(Extreme Programming,或简称XP)讲究TDD，即测试驱动开发，先编写测试代码，再进行开发。在实际的工作中，可以不必过分强调先什么后什么，重要的是高效和感觉舒适。从经验来看， 先编写产品函数的框架，然后编写测试函数，针对产品函数的功能编写测试用例，然后编写产品函数的代码，每写一个功能点都运行测试，随时补充测试用例 。所谓先编写产品函数的框架，是指先编写函数空的实现，有返回值的直接返回一个合适值，编译通过后再编写测试代码，这时，函数名、参数表、返回类型都应该确定下来了，所编写的测试代码以后需修改的可能性比较小。  这是那些没有首先为每个单元编写一个详细的规格说明而直接跳到编码阶段的开发人员提出的一条普遍的抱怨， 当编码完成以后并且面临代码测试任务的时候，他们就阅读这些代码并找出它实际上做了什么，把他们的测试工作基于已经写好的代码的基础上 。当然，他们无法证明任何事情。所有的这些测试工作能够表明的事情就是编译器工作正常。是的，他们也许能够抓住（希望能够）罕见的编译器Bug，但是他们能够做的仅仅是这些。\n如果他们首先写好一个详细的规格说明，测试能够以规格说明为基础。代码就能够针对它的规格说明，而不是针对自身进行测试。这样的测试仍然能够抓住编译器的Bug，同时也能找到更多的编码错误，甚至是一些规格说明中的错误。 好的规格说明可以使测试的质量更高，所以最后的结论是高质量的测试需要高质量的规格说明 。  在实践中会出现这样的情况：一个开发人员要面对测试一个单元时只给出单元的代码而没有规格说明这样吃力不讨好的任务。你怎样做才会有更多的收获，而不仅仅是发现编译器的Bug？ 第一步是理解这个单元原本要做什么， --- 不是它实际上做了什么 。比较有效的方法是倒推出一个概要的规格说明。这个过程的主要输入条件是要阅读那些程序代码和注释， 主要针对这个单元， 及调用它和被它调用的相关代码。 画出流程图是非常有帮助的 ，你可以用手工或使用某种工具。 可以组织对这个概要规格说明的走读（Review)，以确保对这个单元的说明没有基本的错误， 有了这种最小程度的代码深层说明，就可以用它来设计单元测试了 。   go test 时候会先编译检查一遍，和 go run 、 go install 相同，即只有编译检查通过了才会继续。因此 go test 实际上做了2个测试: 传入参数和数量是否正确（不正确就编译报错），以及业务逻辑是否正确。  关于业务逻辑是否正确，我的理解是：假设被测试函数是做除法，在函数里的逻辑会判断传入的参数是否为0，如果为0，则返回error。那么测试内容就是传入0，看下是否返回error，如果没有返回error，则t.Errorf抛错  总结: 编写单元测试时候，根据预设规则，调用被测试函数，依次传入预设的若干情况，来测试函数的返回是否正确。", 
            "title": "我对单元测试的理解"
        }, 
        {
            "location": "/basic/packages/", 
            "text": "每个go程序都是由模块组成的\n\n\n\n\n\n\n程序由main模块开始", 
            "title": "1. Packages"
        }, 
        {
            "location": "/basic/imports/", 
            "text": "import\n \nfmt\n\n\nimport\n \nmath\n\n\n\n\n\n上面这2行可以这么写：\n\n\nimport\n \n(\n\n    \nfmt\n\n    \nmath\n\n\n)\n\n\n\n\n\n官方推荐用第二种带括号的方式", 
            "title": "2. Imports"
        }, 
        {
            "location": "/basic/exportname/", 
            "text": "模块里名字第一个字符大写可以被其他模块引用，而如果首字符是小写则不行，比如\nstringutil.go\n内容:\n\n\n// Package stringutil contains utility functions for working with strings.\n\n\npackage\n \nstringutil\n\n\n\n// Reverse returns its argument string reversed rune-wise left to right.\n\n\nfunc\n \nreverse\n(\ns\n \nstring\n)\n \nstring\n \n{\n\n        \nr\n \n:=\n \n[]\nrune\n(\ns\n)\n\n        \nfor\n \ni\n,\n \nj\n \n:=\n \n0\n,\n \nlen\n(\nr\n)\n-\n1\n;\n \ni\n \n \nlen\n(\nr\n)\n/\n2\n;\n \ni\n,\n \nj\n \n=\n \ni\n+\n1\n,\n \nj\n-\n1\n \n{\n\n                \nr\n[\ni\n],\n \nr\n[\nj\n]\n \n=\n \nr\n[\nj\n],\n \nr\n[\ni\n]\n\n        \n}\n\n        \nreturn\n \nstring\n(\nr\n)\n\n\n}\n\n\n\n\n\nhello.go\n要引用这个模块：\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \ngithub.com/cyent/repo1/stringutil\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintf\n(\nstringutil\n.\nreverse\n(\n!oG ,olleH\n))\n\n\n}\n\n\n\n\n\n这样\nhello.go\n编译会报错：\n\n\n# github.com/cyent/repo1/hello\n./hello.go:10: cannot refer to unexported name stringutil.reverse\n./hello.go:10: undefined: stringutil.reverse\n\n\n\n\n正确应该是：\n\n\nstringutil.go\n内容是：\n\n\n// Package stringutil contains utility functions for working with strings.\n\n\npackage\n \nstringutil\n\n\n\n// Reverse returns its argument string reversed rune-wise left to right.\n\n\nfunc\n \nReverse\n(\ns\n \nstring\n)\n \nstring\n \n{\n\n        \nr\n \n:=\n \n[]\nrune\n(\ns\n)\n\n        \nfor\n \ni\n,\n \nj\n \n:=\n \n0\n,\n \nlen\n(\nr\n)\n-\n1\n;\n \ni\n \n \nlen\n(\nr\n)\n/\n2\n;\n \ni\n,\n \nj\n \n=\n \ni\n+\n1\n,\n \nj\n-\n1\n \n{\n\n                \nr\n[\ni\n],\n \nr\n[\nj\n]\n \n=\n \nr\n[\nj\n],\n \nr\n[\ni\n]\n\n        \n}\n\n        \nreturn\n \nstring\n(\nr\n)\n\n\n}\n\n\n\n\n\nhello.go\n要引用这个模块：\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \ngithub.com/cyent/repo1/stringutil\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintf\n(\nstringutil\n.\nReverse\n(\n!oG ,olleH\n))\n\n\n}\n\n\n\n\n\n这样编译就不会报错了\n\n\n另外，struct中的元素也是遵守首字母大写才可导出的原则，详见\nstruct-导出名", 
            "title": "3. 导出名"
        }, 
        {
            "location": "/basic/function/", 
            "text": "入参\n\n\n\n\n函数可以接收0个或多个参数，参数需要指定类型，返回值也需要指定类型，比如\n\n\nfunc\n \nadd\n(\nx\n \nint\n,\n \ny\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \nx\n \n+\n \ny\n\n\n}\n\n\n\n\n\n上面表示声明一个函数add，接收2个参数，分别都是int类型，返回的类型也是int。\n\n\n\n\n\n\nmain函数不用指定返回类型\n\n\n函数里如果没有\nreturn\n，而是\nfmt.Println\n之类的，就不用指定返回类型\n\n\n\n\n\n\n类型：类型跟在变量名后面，比如\nx\n \nint\n，表示声明一个int类型的变量x\n\n\n\n\n如果想了解为什么长这样，可以看 \nhttps://blog.golang.org/gos-declaration-syntax\n\n\n\n\n\n\n参数类型相同可以简写\n\n\n如果声明的多个参数类型是相同的，可以只写最后一个参数类型，比如上面的\nx\n \nint\n,\n \ny\n \nint\n也可以写成\nx\n,\n \ny\n \nint\n\n\n\n\n出参\n\n\n\n\n返回类型必须指定，比如本页最开始的例子中，如果改成\n\n\nfunc\n \nadd\n(\nx\n \nint\n,\n \ny\n \nint\n)\n \n{\n\n    \nreturn\n \nx\n \n+\n \ny\n\n\n}\n\n\n\n\n\n则报错:\n\n\ntoo many arguments to return\n    have (int)\n    want ()\n\n\n\n\n多返回值：\n\n\nfunc\n \nswap\n(\nx\n,\n \ny\n \nstring\n)\n \n(\nstring\n,\n \nstring\n)\n\n\n\n\n\n返回值命名：\n\n\nfunc\n \nswap\n(\nx\n,\n \ny\n \nstring\n)\n \n(\na\n,\n \nb\n \nstring\n)\n，\n这种通常用于return不跟参数\n\n\n\n\n\nreturn不跟参数：\n\n\nfunc\n \nsplit\n(\nsum\n \nint\n)\n \n(\nx\n,\n \ny\n \nint\n)\n \n{\n\n    \nx\n \n=\n \nsum\n \n*\n \n4\n \n/\n \n9\n\n    \ny\n \n=\n \nsum\n \n-\n \nx\n\n    \nreturn\n\n\n}\n\n\n\n\n\n上面return没有跟任何参数，实际等同于\nreturn x, y\n\n\n即根据\nfunc split(sum int) \n(x, y int)\n顺序来定\n\n\n\n\n这种return不跟参数方式不推荐，这种方式仅适用于比较短的函数，如果函数比较长，这样可读性就很不好了", 
            "title": "4. 函数"
        }, 
        {
            "location": "/basic/function/#_1", 
            "text": "函数可以接收0个或多个参数，参数需要指定类型，返回值也需要指定类型，比如  func   add ( x   int ,   y   int )   int   { \n     return   x   +   y  }   上面表示声明一个函数add，接收2个参数，分别都是int类型，返回的类型也是int。    main函数不用指定返回类型  函数里如果没有 return ，而是 fmt.Println 之类的，就不用指定返回类型    类型：类型跟在变量名后面，比如 x   int ，表示声明一个int类型的变量x   如果想了解为什么长这样，可以看  https://blog.golang.org/gos-declaration-syntax    参数类型相同可以简写  如果声明的多个参数类型是相同的，可以只写最后一个参数类型，比如上面的 x   int ,   y   int 也可以写成 x ,   y   int", 
            "title": "入参"
        }, 
        {
            "location": "/basic/function/#_2", 
            "text": "返回类型必须指定，比如本页最开始的例子中，如果改成  func   add ( x   int ,   y   int )   { \n     return   x   +   y  }   则报错:  too many arguments to return\n    have (int)\n    want ()  多返回值：  func   swap ( x ,   y   string )   ( string ,   string )   返回值命名：  func   swap ( x ,   y   string )   ( a ,   b   string ) ， 这种通常用于return不跟参数   return不跟参数：  func   split ( sum   int )   ( x ,   y   int )   { \n     x   =   sum   *   4   /   9 \n     y   =   sum   -   x \n     return  }   上面return没有跟任何参数，实际等同于 return x, y  即根据 func split(sum int)  (x, y int) 顺序来定   这种return不跟参数方式不推荐，这种方式仅适用于比较短的函数，如果函数比较长，这样可读性就很不好了", 
            "title": "出参"
        }, 
        {
            "location": "/basic/variable_declare/", 
            "text": "var\n\n\n\n\n变量声明用\nvar\n关键字，可以用在函数级别，也可以用在包级别，比如\n\n\nvar\n \nc\n,\n \npython\n,\n \njava\n \nbool\n    \n//这个就是在包级别\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \ni\n \nint\n     \n//这个就是在函数级别\n\n\n}\n\n\n\n\n\n注意：\n\n\nvar多个变量时不能为每个变量设定类型（无论类型是否相同，无论是否有带初始值）比如：\n\n\n\n\n\n\n\n\n语句\n\n\n结果\n\n\n\n\n\n\n\n\n\n\nvar i int, j int\n\n\n报错\n\n\n\n\n\n\nvar i int, j int = 1, 2\n\n\n报错\n\n\n\n\n\n\nvar i string, j int\n\n\n报错\n\n\n\n\n\n\nvar i string, j int = \"a\", 1\n\n\n报错\n\n\n\n\n\n\n\n\nvar多个变量带初始值，如果类型不同，就不能指定变量类型，比如：\n\n\n\n\n\n\n\n\n语句\n\n\n结果\n\n\n\n\n\n\n\n\n\n\nvar i, j = \"aa\", 2\n\n\n正确\n\n\n\n\n\n\nvar i, j int = \"aa\", 2\n\n\n报错\n\n\n\n\n\n\n\n\nvar是否跟类型（包括var单个变量或者var多个变量）：\n\n\n\n\n\n\n跟类型：\n\n\n\n\n\n\n带初始值: OK\n\n\n单个变量例子：\nvar\n \ni\n \nint\n \n=\n \n1\n\n\n多个变量例子：\nvar\n \ni\n,\n \nj\n \nint\n \n=\n \n1\n,\n \n2\n\n\n\n\n\n\n不带初始值: 根据类型自动设初始值，如int初始值为0，string初始值为\"\"（空字符）\n\n\n单个变量例子：\nvar\n \ni\n \nint\n，则i为0\n\n\n多个变量例子：\nvar\n \ni\n,\n \nj\n \nint\n，则i和j为0\n\n\n\n\n\n\n\n\n\n\n不跟类型：\n\n\n\n\n\n\n带初始值: 根据初始值自动判断类型，如1为int类型，\"a\"为string类型\n\n\n单个变量例子：\nvar\n \ni\n \n=\n \n1\n，则i为int类型\n\n\n多个变量例子：\n\n\n\n\n\n\nvar\n \ni\n,\n \nj\n \n=\n \n1\n,\n \n2\n，则i和j为int类型\n\n\n\n\n\n\nvar\n \ni\n,\n \nj\n \n=\n \ntrue\n,\n \na\n，则i为bool类型，j为string类型\n\n\n\n\n\n\n\n\n\n\n不带初始值: 报错\n\n\n单个变量例子：\nvar\n \ni\n，会报错\n\n\n多个变量例子：\nvar\n \ni\n,\n \nj\n，会报错\n\n\n\n\n\n\n\n\n\n\n:=\n\n\n\n\n:=\n是短声明变量，也叫简洁赋值语句\n\n\n函数内，\n:=\n 用在明确类型的地方（但不能显式指定类型），可以用于替代\nvar\n定义。\n\n\n函数外（即包级别）的每个语句都必须以关键字开始（\nvar\n、\nfunc\n等），\n:=\n 不能使用在函数外，如：\n\n\nvar\n \nk\n \n=\n \n3\n   \n//OK\n\n\nk\n \n:=\n \n3\n      \n//报错\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nk\n \n:=\n \n3\n          \n//OK\n\n    \nvar\n \nk\n \nint\n \n=\n \n3\n   \n//OK\n\n    \nk\n \nint\n \n:=\n \n3\n      \n//报错\n\n    \nvar\n \nk\n \n:=\n \n3\n      \n//报错\n\n    \nvar\n \nk\n \nint\n \n:=\n \n3\n  \n//报错\n\n\n}", 
            "title": "5.1. 声明"
        }, 
        {
            "location": "/basic/variable_declare/#var", 
            "text": "变量声明用 var 关键字，可以用在函数级别，也可以用在包级别，比如  var   c ,   python ,   java   bool      //这个就是在包级别  func   main ()   { \n     var   i   int       //这个就是在函数级别  }   注意：  var多个变量时不能为每个变量设定类型（无论类型是否相同，无论是否有带初始值）比如：     语句  结果      var i int, j int  报错    var i int, j int = 1, 2  报错    var i string, j int  报错    var i string, j int = \"a\", 1  报错     var多个变量带初始值，如果类型不同，就不能指定变量类型，比如：     语句  结果      var i, j = \"aa\", 2  正确    var i, j int = \"aa\", 2  报错     var是否跟类型（包括var单个变量或者var多个变量）：    跟类型：    带初始值: OK  单个变量例子： var   i   int   =   1  多个变量例子： var   i ,   j   int   =   1 ,   2    不带初始值: 根据类型自动设初始值，如int初始值为0，string初始值为\"\"（空字符）  单个变量例子： var   i   int ，则i为0  多个变量例子： var   i ,   j   int ，则i和j为0      不跟类型：    带初始值: 根据初始值自动判断类型，如1为int类型，\"a\"为string类型  单个变量例子： var   i   =   1 ，则i为int类型  多个变量例子：    var   i ,   j   =   1 ,   2 ，则i和j为int类型    var   i ,   j   =   true ,   a ，则i为bool类型，j为string类型      不带初始值: 报错  单个变量例子： var   i ，会报错  多个变量例子： var   i ,   j ，会报错", 
            "title": "var"
        }, 
        {
            "location": "/basic/variable_declare/#_1", 
            "text": ":= 是短声明变量，也叫简洁赋值语句  函数内， :=  用在明确类型的地方（但不能显式指定类型），可以用于替代 var 定义。  函数外（即包级别）的每个语句都必须以关键字开始（ var 、 func 等）， :=  不能使用在函数外，如：  var   k   =   3     //OK  k   :=   3        //报错  func   main ()   { \n     k   :=   3            //OK \n     var   k   int   =   3     //OK \n     k   int   :=   3        //报错 \n     var   k   :=   3        //报错 \n     var   k   int   :=   3    //报错  }", 
            "title": ":="
        }, 
        {
            "location": "/basic/variable_affect/", 
            "text": "在包级别定义的变量，是全局变量，即在main函数里对这个变量做的修改，或者在其他函数里对这个变量做的修改，都是真实改了这个变量的值\n\n\n\n\n\n\n在函数里（包括main函数或其他函数）定义的变量，只在自己函数里有效，若在其他函数里对这个变量做修改，会提示undefined\n\n\n\n\n\n\n可以存在变量名相同，但作用域不同的多个变量。（个人觉得太晦涩，不建议这么用）\n\n\n\n\n\n\n函数内部的函数（即函数值），有前后顺序要求\n\n\n\n\n\n\n例1. 包级别的变量能否被函数引用?\nvar\n \nA\n \nint\n \n=\n \n1\n\n\nfunc\n \nfoo\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfoo\n()\n\n\n}\n\n\n\n\n输出\n1\n\n\n\n答: 包级别的变量可以被函数引用\n例2. 包级别的函数是否有顺序要求?\nvar\n \nA\n \nint\n \n=\n \n1\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfoo\n()\n\n\n}\n\n\nfunc\n \nfoo\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\n\n\n输出\n1\n\n\n\n答: 包级别的函数没有顺序要求\n例3. 一个函数里的变量能否被包级别的另一个函数引用?\nfunc\n \nfoo\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \nA\n \nint\n \n=\n \n1\n\n    \nfoo\n()\n\n\n}\n\n\n\n\n报错\nundefined: A\n\n\n\n答: 一个函数里的变量不能被包级别的另一个函数引用\n例4. 一个函数里的变量能否被内嵌的函数值引用?\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \nA\n \nint\n \n=\n \n1\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nfmt\n.\nPrintln\n(\nA\n)\n\n    \n}\n\n    \nfoo\n()\n\n\n}\n\n\n\n\n输出\n1\n\n\n\n答: 一个函数里的变量可以被内嵌的函数值引用\n例5. 函数值是否有顺序要求?\nfunc\n \nmain\n()\n \n{\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nfmt\n.\nPrintln\n(\nA\n)\n\n    \n}\n\n    \nvar\n \nA\n \nint\n \n=\n \n1\n\n    \nfoo\n()\n\n\n}\n\n\n\n\n报错\nundefined: A\n\n\n\n答: 函数值有顺序要求\n例6. 包级别的变量能否在函数内部的函数值里引用?\nvar\n \nA\n \nint\n \n=\n \n1\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nA\n \n=\n \n2\n\n    \n}\n\n    \nfoo\n()\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\n\n\n输出\n2\n\n\n\n答: 包级别的变量可以在函数内部的函数值里引用\n例7. 函数值嵌套函数值，还能否引用外部变量?\nfunc\n \nmain\n()\n \n{\n\n    \nA\n \n:=\n \n1\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nbar\n \n:=\n \nfunc\n \n()\n \n{\n\n            \nA\n \n=\n \n2\n\n        \n}\n\n        \nbar\n()\n\n    \n}\n\n    \nfoo\n()\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\n\n\n输出\n2\n\n\n\n答: 函数值嵌套函数值，可以引用外部变量\n例8. 是否可以存在不同作用域，但名字相同的变量(本例十分经典)?\nfunc\n \nmain\n()\n \n{\n\n    \nA\n \n:=\n \n1\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nA\n \n=\n \n2\n\n        \nA\n \n:=\n \n3\n\n        \nA\n \n=\n \n4\n\n        \nfmt\n.\nPrintln\n(\nA\n)\n\n    \n}\n\n    \nfoo\n()\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\n\n\n输出\n4\n2\n\n\n\n答: 可以存在不同作用域，但名字相同的变量\n例9. 本例与例8相似，若一开始就声明同名的变量名，那么还能否引用外部同名变量?\nfunc\n \nmain\n()\n \n{\n\n    \nA\n \n:=\n \n1\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nA\n \n:=\n \n3\n\n        \nA\n \n=\n \n2\n\n        \nfmt\n.\nPrintln\n(\nA\n)\n\n    \n}\n\n    \nfoo\n()\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\n\n\n输出\n2\n1\n\n\n\n答: 若一开始就声明同名的变量名，则无法再引用外部同名变量\n例子总结:\n\n\n\n\n\n\n例1-例7：包级别的函数，写上面或写下面都一样（包括和引用的变量，以及被引用的上层函数，比如变量A的声明写在foo函数声明后，或者foo函数写在main函数上面或者下面），而写在函数里（比如main函数）里的函数（函数值），则和顺序有关，比如在函数值里面引用的变量如果是在这个函数值上面声明的，则可以引用，如果是在函数值下面声明的则提示undefined\n\n\n\n\n\n\n例8-例9：可以看到如果在函数内部声明一个函数外部已经存在的变量，则在函数内部，这个变量和函数的变量只是名字相同，但实际是2个变量\n\n\n\n\n\n\n例3-例4：可以看到把函数放到包级别比较好，因为main函数里声明的变量无法直接被这个函数里引用，即安全性提高了，不容易误操作\n\n\n\n\n\n\n关于for、if等带有代码块的作用域，详见各自章节\n:\n\n\n\n\n\n\nfor作用域\n\n\n\n\n\n\nif作用域\n\n\n\n\n\n\nswitch作用域", 
            "title": "5.2. 作用域"
        }, 
        {
            "location": "/basic/const/", 
            "text": "声明\n\n\n\n\n用const声明，无论在包级别还是函数级别。不能用:=\n\n\n常量只能是字符串、布尔、数字类型（整数、浮点数、复数）的值\n\n\nconst\n \nfoo\n \n=\n \nbar\n\n\n\n\n\n上面声明一个常量，常量名叫foo，值是\"bar\"，foo的类型自动推导为string\n\n\n也可以\nconst\n \nfoo\n \nstring\n \n=\n \nbar\n来直接指定类型\n\n\n注意%T是查看类型，即string还是int，而看不出是常量还是变量\n\n\n作用域\n\n\n\n\n经测试，常量作用域和变量作用域相同。\n\n\n数值常量\n\n\n\n\n\n\n\n\n是高精度的值\n\n\n\n\n\n\n未指定类型的常量由上下文来决定其类型", 
            "title": "6. 常量"
        }, 
        {
            "location": "/basic/const/#_1", 
            "text": "用const声明，无论在包级别还是函数级别。不能用:=  常量只能是字符串、布尔、数字类型（整数、浮点数、复数）的值  const   foo   =   bar   上面声明一个常量，常量名叫foo，值是\"bar\"，foo的类型自动推导为string  也可以 const   foo   string   =   bar 来直接指定类型  注意%T是查看类型，即string还是int，而看不出是常量还是变量", 
            "title": "声明"
        }, 
        {
            "location": "/basic/const/#_2", 
            "text": "经测试，常量作用域和变量作用域相同。", 
            "title": "作用域"
        }, 
        {
            "location": "/basic/const/#_3", 
            "text": "是高精度的值    未指定类型的常量由上下文来决定其类型", 
            "title": "数值常量"
        }, 
        {
            "location": "/basic/type_main/", 
            "text": "// Bool类型\n\n\nvar\n \nmy_bool\n \nbool\n \n=\n \ntrue\n\n\n\n// 字符串类型\n\n\nvar\n \nmy_string\n \nstring\n \n=\n \nhello, world!\n\n\n\n// int: 有符号整形，根据系统架构自动判断是int8，int16，int32还是int64\n\n\n// 比如当前系统是64位系统，则为int64\n\n\nvar\n \nmy_int_min\n \nint\n \n=\n \n-\n9223372036854775808\n\n\nvar\n \nmy_int_max\n \nint\n \n=\n \n9223372036854775807\n\n\n\n// int8: 有符号 8 位整型 (-128 到 127)\n\n\nvar\n \nmy_int8_min\n \nint8\n \n=\n \n-\n128\n\n\nvar\n \nmy_int8_max\n \nint8\n \n=\n \n127\n\n\n\n// int16: 有符号 16 位整型 (-32768 到 32767)\n\n\nvar\n \nmy_int16_min\n \nint16\n \n=\n \n-\n32768\n\n\nvar\n \nmy_int16_max\n \nint16\n \n=\n \n32767\n\n\n\n// int32: 有符号 32 位整型 (-2147483648 到 2147483647)\n\n\nvar\n \nmy_int32_min\n \nint32\n \n=\n \n-\n2147483648\n\n\nvar\n \nmy_int32_max\n \nint32\n \n=\n \n2147483647\n\n\n\n// int64: 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)\n\n\nvar\n \nmy_int64_min\n \nint64\n \n=\n \n-\n9223372036854775808\n\n\nvar\n \nmy_int64_max\n \nint64\n \n=\n \n9223372036854775807\n\n\n\n// uint: 无符号整形，根据系统架构自动判断是uint8，uint16，uint32还是uint64\n\n\n// 比如当前系统是64位系统，则为uint64\n\n\nvar\n \nmy_uint_min\n \nuint\n \n=\n \n0\n\n\nvar\n \nmy_uint_max\n \nuint\n \n=\n \n18446744073709551615\n\n\n\n// uint8: 无符号 8 位整型 (0 到 255)\n\n\nvar\n \nmy_uint8_min\n \nuint8\n \n=\n \n0\n\n\nvar\n \nmy_uint8_max\n \nuint8\n \n=\n \n255\n\n\n\n// uint16: 无符号 16 位整型 (0 到 65535)\n\n\nvar\n \nmy_uint16_min\n \nuint16\n \n=\n \n0\n\n\nvar\n \nmy_uint16_max\n \nuint16\n \n=\n \n65535\n\n\n\n// uint32: 无符号 32 位整型 (0 到 4294967295)\n\n\nvar\n \nmy_uint32_min\n \nuint32\n \n=\n \n0\n\n\nvar\n \nmy_uint32_max\n \nuint32\n \n=\n \n4294967295\n\n\n\n// uint64: 无符号 64 位整型 (0 到 18446744073709551615)\n\n\nvar\n \nmy_uint64_min\n \nuint64\n \n=\n \n0\n\n\nvar\n \nmy_uint64_max\n \nuint64\n \n=\n \n18446744073709551615\n\n\n\n// uintptr: 无符号整型，用于存放一个指针，可以足够保存指针的值的范围。和uint范围相同，根据系统架构自动判断\n\n\nvar\n \nmy_uintptr_min\n \nuintptr\n \n=\n \n0\n\n\nvar\n \nmy_uintptr_max\n \nuintptr\n \n=\n \n18446744073709551615\n\n\n\n// byte: uint8的别名\n\n\nvar\n \nmy_byte_min\n \nbyte\n \n=\n \n0\n\n\nvar\n \nmy_byte_max\n \nbyte\n \n=\n \n255\n\n\n\n// rune: int32的别名。代表1个unicode码\n\n\nvar\n \nmy_rune_min\n \nrune\n \n=\n \n-\n2147483648\n\n\nvar\n \nmy_rune_max\n \nrune\n \n=\n \n2147483647\n\n\n\n// float32: 单精度浮点数，在C语言里等同于float\n\n\n// float64: 双精读浮点数，在C语言里等同于double\n\n\n// 如果不写类型，则为float64（暂时不知道这个是根据系统架构判断还是默认就是float64）\n\n\n// 从结果可以看出:\n\n\n//   float32只能容纳8位数字（包括小数点前后数字，不包括小数点，超过8位会将四舍五入保留8位）\n\n\n//   float64可以容纳比较多的数字（具体暂时还没测），而且这种双精度我也一直没搞懂，很复杂\n\n\n//   当符合要求时候会自动用科学计数法来表示，要注意\n\n\nvar\n \nmy_float32\n \nfloat32\n \n=\n \n10086.141592653\n\n\nvar\n \nmy_float64\n \nfloat64\n \n=\n \n10086.141592653\n\n\nvar\n \nmy_float_auto\n \n=\n \n10086.141592653\n\n\n\n\n\n输出\n\n\nbool: true\nstring: hello, world!\nint min: -9223372036854775808\nint max: 9223372036854775807\nint8 min: -128\nint8 max: 127\nint16 min: -32768\nint16 max: 32767\nint32 min: -2147483648\nint32 max: 2147483647\nint64 min: -9223372036854775808\nint64 max: 9223372036854775807\nuint min: 0\nuint max: 18446744073709551615\nuint8 min: 0\nuint8 max: 255\nuint16 min: 0\nuint16 max: 65535\nuint32 min: 0\nuint32 max: 4294967295\nuint64 min: 0\nuint64 max: 18446744073709551615\nuintptr min: 0\nuintptr max: 18446744073709551615\nbyte min: 0\nbyte max: 255\nrune min: -2147483648\nrune max: 2147483647\nfloat32: 10086.142\nfloat64: 10086.141592653\nfloat_auto: 10086.141592653\n\n\n\n\n除了上述的数据类型，还有2个复数：complex64、complex128\n\n\n\n\n-0和0\n\n\n-0等于0，用-0能编译通过，实际输出就是0。无论是unit还是int\n\n\n\n\n\n\nint8\n\n\nint8意思是用二进制表示的话，从左往右第1位表示正数或是负数，第1位为0表示正数，1表示负数\n\n\n为什么int8最小是-128而最大是127，感觉不对称，但是正确的。是因为00000000和10000000都可以表示0，但是没必要存在2个0，因此往负数方向移1位，即00000000表示0，而10000000表示为-1，那么11111111就表示为-128。", 
            "title": "7.1. 介绍"
        }, 
        {
            "location": "/basic/type_default/", 
            "text": "数字类型（如int、 float64）默认值是0\n\n\n布尔类型默认值是false\n\n\n字符串类型默认值是\"\"（空字符串）", 
            "title": "7.2. 默认值"
        }, 
        {
            "location": "/basic/type_change/", 
            "text": "用T(v)表达式来将变量v转换成类型T\n\n\n\n\n必须指定类型才能转换\n\n\nvar a int = 5，那么：\n\n\nvar b string = string(a) 是OK的，而var b string = a是会报错的\n\n\n\n\n另外，var b = string(a)，或者b := string(a)也可以", 
            "title": "7.3. 类型转换"
        }, 
        {
            "location": "/basic/type_guess/", 
            "text": "当定义一个变量却不显式指定类型时候，类型由值推导而出\n\n\nvar\n \ni\n \nint\n\n\nj\n \n:=\n \ni\n  \n//j是int类型\n\n\nk\n \n:=\n \n0\n  \n//k是int类型\n\n\n\n\n\n但是如果值是数字时候，则新的变量可能是int、float64、complex128，这取决于常量的精度\n\n\ni\n \n:=\n \n42\n           \n// int\n\n\nf\n \n:=\n \n3.142\n        \n// float64\n\n\ng\n \n:=\n \n0.867\n \n+\n \n0.5i\n \n// complex128\n\n\n\n\n\n%T\n可以查看类型\n\n\nfmt\n.\nPrintf\n(\n%T\n,\n \na\n)", 
            "title": "7.4. 类型推导"
        }, 
        {
            "location": "/basic/type_custom/", 
            "text": "声明\n\n\n\n\ntype 自定义类型 原始类型\n\n\n\n\n例如\n\n\ntype MyInt int\n\n\n\n\n\n\n声明可以放在包级别也可以放在函数级别\n\n\n\n\n原始类型也可以是自定义类型，例如\n\n\ntype MyInt int\ntype AbInt MyInt\n\n\n\n\n可以缩写为\n\n\ntype (\n    MyInt int\n    AbInt MyInt\n)\n\n\n\n\n赋值\n\n\n\n\n有2种方式:\n\n\n\n\n\n\n使用强制类型转换的方法来赋值\n\n\n类型(值)\n\n\n\n\n例如\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nMyInt\n \nint\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nMyInt\n(\n1\n)\n\n    \nfmt\n.\nPrintf\n(\n%T, %d\\n\n,\n \na\n,\n \na\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nmain.MyInt, 1\n\n\n\n\n\n\n\n\n普通方式\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nMyInt\n \nint\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \nMyInt\n\n    \na\n \n=\n \n1\n\n    \nfmt\n.\nPrintf\n(\n%T, %d\\n\n,\n \na\n,\n \na\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nmain.MyInt, 1\n\n\n\n\n\n\n\n\n注意\n\n\n\n\n\n\n\n\n原始类型可以是另一个自定义类型，例如\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \n(\n\n    \nMyInt\n \nint\n\n    \nAbInt\n \nMyInt\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nMyInt\n(\n1\n)\n\n    \nb\n \n:=\n \nAbInt\n(\n2\n)\n\n    \nfmt\n.\nPrintf\n(\n%T, %T\\n\n,\n \na\n,\n \nb\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nmain.MyInt, main.AbInt\n\n\n\n\n\n\n\n\n自定义类型不能与原始类型进行计算\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nMyInt\n \nint\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nMyInt\n(\n1\n)\n\n    \nb\n \n:=\n \n2\n\n    \nfmt\n.\nPrintln\n(\na\n \n+\n \nb\n)\n\n\n}\n\n\n\n\n\n报错\n\n\n./type_custom.go:10: invalid operation: a + b (mismatched types MyInt and int)\n\n\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \n(\n\n    \nMyInt\n \nint\n\n    \nAAInt\n \nMyInt\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nMyInt\n(\n1\n)\n\n    \nb\n \n:=\n \nAAInt\n(\n2\n)\n\n    \nfmt\n.\nPrintf\n(\n%T, %T\\n\n,\n \na\n,\n \nb\n)\n\n    \nfmt\n.\nPrintln\n(\na\n,\n \nb\n)\n\n    \nfmt\n.\nPrintln\n(\na\n+\nb\n)\n\n\n}\n\n\n\n\n\n报错\n\n\n./type_custom.go:15: invalid operation: a + b (mismatched types MyInt and AAInt)\n\n\n\n\n\n\n\n\nfmt.Printf\n的\n%d\n可以用于最终原始类型是int的MyInt\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \n(\n\n    \nMyInt\n \nint\n\n    \nAAInt\n \nMyInt\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nMyInt\n(\n1\n)\n\n    \nb\n \n:=\n \nAAInt\n(\n2\n)\n\n    \nfmt\n.\nPrintf\n(\n%T, %T\\n\n,\n \na\n,\n \nb\n)\n\n    \nfmt\n.\nPrintln\n(\na\n,\n \nb\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nmain.MyInt, main.AAInt\n1 2\n\n\n\n\n\n\n\n\n可以把type写在main里，比如：\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ntype\n \ncc\n \nint\n\n    \ntype\n \ndd\n \ncc\n\n    \nvar\n \nc\n \ncc\n\n    \nvar\n \nd\n \ndd\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nc\n)\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nd\n)\n\n    \nfmt\n.\nPrintln\n(\nc\n)\n\n    \nfmt\n.\nPrintln\n(\nd\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nmain.cc\nmain.dd\n0\n0\n\n\n\n\n但是只有放在包级别的，并且首字母大写的，才能被导入给其他模块引用\n\n\n\n\n\n\n自定义type具有隐藏原type的效果\n\n\ntype\n \nfoo\n \nint\n\n\ntype\n \nbar\n \n[]\nint\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n[]\nfoo\n{\n1\n,\n \n2\n,\n \n3\n}\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n    \nb\n \n:=\n \nbar\n{\n1\n,\n \n2\n,\n \n3\n}\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nb\n)\n\n    \nfmt\n.\nPrintln\n(\nb\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n[]main.foo\n[1 2 3]\nmain.bar\n[1 2 3]\n\n\n\n\nfoo和bar最终是相似效果，但bar通过%T看不到[]\n\n\n\n\n\n\nTYPE(同类型的值)可以做类型转换，比如：\n\n\ntype\n \nfoo\n \nint\n\n\na\n \n:=\n \nfoo\n(\n1\n)\n\n\n\ntype\n \nbar\n \n[]\nint\n\n\nc\n \n:=\n \n[]\nint\n{\n1\n,\n \n2\n,\n \n3\n}\n\n\nd\n \n:=\n \nbar\n(\nc\n)\n\n\n\n\n\n上面的类型转换都是将原来的值转换为新的类型，只不过新的类型和原来的类型其实是一样的而已。\n\n\n当然也能将不同类型的做转换（前提是golang允许转换的），比如string(1)，就是将int类型的1转换成string类型，只不过不是转换成\"1\"，而是其他算法（ascii或者utf8？），但反过来int(\"1\")就会报错\n\n\n也可以将int转成float64，或者将floaf64转成int类型", 
            "title": "7.5. 自定义类型"
        }, 
        {
            "location": "/basic/type_custom/#_1", 
            "text": "type 自定义类型 原始类型  例如  type MyInt int   声明可以放在包级别也可以放在函数级别   原始类型也可以是自定义类型，例如  type MyInt int\ntype AbInt MyInt  可以缩写为  type (\n    MyInt int\n    AbInt MyInt\n)", 
            "title": "声明"
        }, 
        {
            "location": "/basic/type_custom/#_2", 
            "text": "有2种方式:    使用强制类型转换的方法来赋值  类型(值)  例如  package   main  import   fmt  type   MyInt   int  func   main ()   { \n     a   :=   MyInt ( 1 ) \n     fmt . Printf ( %T, %d\\n ,   a ,   a )  }   输出  main.MyInt, 1    普通方式  package   main  import   fmt  type   MyInt   int  func   main ()   { \n     var   a   MyInt \n     a   =   1 \n     fmt . Printf ( %T, %d\\n ,   a ,   a )  }   输出  main.MyInt, 1", 
            "title": "赋值"
        }, 
        {
            "location": "/basic/type_custom/#_3", 
            "text": "原始类型可以是另一个自定义类型，例如  package   main  import   fmt  type   ( \n     MyInt   int \n     AbInt   MyInt  )  func   main ()   { \n     a   :=   MyInt ( 1 ) \n     b   :=   AbInt ( 2 ) \n     fmt . Printf ( %T, %T\\n ,   a ,   b )  }   输出  main.MyInt, main.AbInt    自定义类型不能与原始类型进行计算  package   main  import   fmt  type   MyInt   int  func   main ()   { \n     a   :=   MyInt ( 1 ) \n     b   :=   2 \n     fmt . Println ( a   +   b )  }   报错  ./type_custom.go:10: invalid operation: a + b (mismatched types MyInt and int)  package   main  import   fmt  type   ( \n     MyInt   int \n     AAInt   MyInt  )  func   main ()   { \n     a   :=   MyInt ( 1 ) \n     b   :=   AAInt ( 2 ) \n     fmt . Printf ( %T, %T\\n ,   a ,   b ) \n     fmt . Println ( a ,   b ) \n     fmt . Println ( a + b )  }   报错  ./type_custom.go:15: invalid operation: a + b (mismatched types MyInt and AAInt)    fmt.Printf 的 %d 可以用于最终原始类型是int的MyInt  package   main  import   fmt  type   ( \n     MyInt   int \n     AAInt   MyInt  )  func   main ()   { \n     a   :=   MyInt ( 1 ) \n     b   :=   AAInt ( 2 ) \n     fmt . Printf ( %T, %T\\n ,   a ,   b ) \n     fmt . Println ( a ,   b )  }   输出  main.MyInt, main.AAInt\n1 2    可以把type写在main里，比如：  func   main ()   { \n     type   cc   int \n     type   dd   cc \n     var   c   cc \n     var   d   dd \n     fmt . Printf ( %T\\n ,   c ) \n     fmt . Printf ( %T\\n ,   d ) \n     fmt . Println ( c ) \n     fmt . Println ( d )  }   输出  main.cc\nmain.dd\n0\n0  但是只有放在包级别的，并且首字母大写的，才能被导入给其他模块引用    自定义type具有隐藏原type的效果  type   foo   int  type   bar   [] int  func   main ()   { \n     a   :=   [] foo { 1 ,   2 ,   3 } \n     fmt . Printf ( %T\\n ,   a ) \n     fmt . Println ( a ) \n\n     b   :=   bar { 1 ,   2 ,   3 } \n     fmt . Printf ( %T\\n ,   b ) \n     fmt . Println ( b )  }   输出  []main.foo\n[1 2 3]\nmain.bar\n[1 2 3]  foo和bar最终是相似效果，但bar通过%T看不到[]    TYPE(同类型的值)可以做类型转换，比如：  type   foo   int  a   :=   foo ( 1 )  type   bar   [] int  c   :=   [] int { 1 ,   2 ,   3 }  d   :=   bar ( c )   上面的类型转换都是将原来的值转换为新的类型，只不过新的类型和原来的类型其实是一样的而已。  当然也能将不同类型的做转换（前提是golang允许转换的），比如string(1)，就是将int类型的1转换成string类型，只不过不是转换成\"1\"，而是其他算法（ascii或者utf8？），但反过来int(\"1\")就会报错  也可以将int转成float64，或者将floaf64转成int类型", 
            "title": "注意"
        }, 
        {
            "location": "/flow/for/", 
            "text": "基本格式\n\n\n\n\ngolang里循环只有for一种，没有其他的（比如其他语言还有while）\n\n\n语法：\n\n\nfor\n \ninit\n \nstatement\n;\n \ncondition\n \nexpression\n;\n \npost\n \nstatement\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\n没有括号\n\n\ninit statement; condition expression; post statement\n前后没有括号\n()\n\n\n\n\n举例\n\n\nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n \n{\n\n    \nsum\n \n+=\n \ni\n\n\n}\n\n\n\n\n\n\n\ninit statement里不能用var\n\n\n这里\ni := 0\n不能写成\nvar i int = 0\n，因为这个地方要求不能用\nvar\n，只能用\n:=\n，如果一定要\nvar\n，要在\nfor\n前先\nvar\n，比如这样也是可以的：\n\n\nvar\n \ni\n \nint\n\n\nfor\n \ni\n \n=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n \n++\n \n{\n\n    \nsum\n \n+=\n \ni\n\n\n}\n\n\n\n\n\n\n\n简写格式\n\n\n\n\ninit statement和post statement是可选的，因此可以忽略，比如：\n\n\nsum\n \n:=\n \n1\n\n\nfor\n \n;\n \nsum\n \n \n1000\n;\n \n{\n\n    \nsum\n \n+=\n \nsum\n\n\n}\n\n\n\n\n\n可以省略分号，即可以写成（这种写法相当于C语言中的while）\n\n\nsum\n \n:=\n \n1\n\n\nfor\n \nsum\n \n \n1000\n \n{\n\n    \nsum\n \n+=\n \nsum\n\n\n}\n\n\n\n\n\n\n\n分号只能都要，或者都不要\n\n\n下面这2种是错的\n\n\nfor\n \n;\n \nsum\n \n \n1000\n \n{\n\n    \nsum\n \n+=\n \nsum\n\n\n}\n\n\n\n\n\n或\n\n\nfor\n \nsum\n \n \n1000\n;\n \n{\n\n    \nsum\n \n+=\n \nsum\n\n\n}\n\n\n\n\n\n\n\n死循环\n\n\n\n\nfor\n \n{\n\n\n}\n\n\n\n\n\n结合range\n\n\n\n\n结合range可以对slice、map、数组、字符串等进行迭代循环\n\n\nfor\n \nkey\n,\n \nvalue\n \n:=\n \nrange\n \noldMap\n \n{\n\n    \nnewMap\n[\nkey\n]\n \n=\n \nvalue\n\n\n}\n\n\n\n\n\n比如：\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nnumbers\n \n:=\n \n[\n6\n]\nint\n{\n1\n,\n \n2\n,\n \n3\n,\n \n5\n}\n\n\n    \nfor\n \ni\n,\n \nx\n \n:=\n \nrange\n \nnumbers\n \n{\n\n        \nfmt\n.\nPrintf\n(\n第 %d 位 x 的值 = %d\\n\n,\n \ni\n,\n \nx\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n点击查看\nrange详解\n\n\n作用域\n\n\n\n\n以下均为个人理解，不保证准确性\n\n\n\n\n\n\nfor的init statement里声明的变量，以及代码块里声明的变量，都仅限于for里，在外部是无法引用的\n\n\n例子\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n2\n;\n \ni\n \n++\n \n{\n\n        \nfmt\n.\nPrintln\n(\ni\n)\n\n        \na\n \n:=\n \n100\n\n    \n}\n\n    \nfmt\n.\nPrintln\n(\ni\n)\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n}\n\n\n\n\n报错\n./for.go:10: undefined: i\n./for.go:11: undefined: a\n\n\n\n\n\n\n\n每次循环都是一个新的空间，即在第一次循环时候声明的变量，在下一次循环时候是看不到的\n\n\n例子\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \nint\n \n=\n \n100\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n    \nfmt\n.\nPrintln\n(\n=====\n)\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n2\n;\n \ni\n \n++\n \n{\n\n        \nfmt\n.\nPrintln\n(\n---\n)\n\n        \na\n \n+=\n \n1\n\n        \nfmt\n.\nPrintln\n(\na\n)\n\n        \na\n \n:=\n \n200\n\n        \nfmt\n.\nPrintln\n(\na\n)\n\n        \na\n \n+=\n \n1\n\n        \nfmt\n.\nPrintln\n(\na\n)\n\n    \n}\n\n    \nfmt\n.\nPrintln\n(\n=====\n)\n\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n}\n\n\n\n\n输出\n100\n=====\n---\n101\n200\n201\n---\n102\n200\n201\n=====\n102\n\n\n\n可以看到每次循环时候a都是200，而不会传递到下次循环中", 
            "title": "1. for"
        }, 
        {
            "location": "/flow/for/#_1", 
            "text": "golang里循环只有for一种，没有其他的（比如其他语言还有while）  语法：  for   init   statement ;   condition   expression ;   post   statement   { \n     ...  }    没有括号  init statement; condition expression; post statement 前后没有括号 ()   举例  for   i   :=   0 ;   i     10 ;   i ++   { \n     sum   +=   i  }    init statement里不能用var  这里 i := 0 不能写成 var i int = 0 ，因为这个地方要求不能用 var ，只能用 := ，如果一定要 var ，要在 for 前先 var ，比如这样也是可以的：  var   i   int  for   i   =   0 ;   i     10 ;   i   ++   { \n     sum   +=   i  }", 
            "title": "基本格式"
        }, 
        {
            "location": "/flow/for/#_2", 
            "text": "init statement和post statement是可选的，因此可以忽略，比如：  sum   :=   1  for   ;   sum     1000 ;   { \n     sum   +=   sum  }   可以省略分号，即可以写成（这种写法相当于C语言中的while）  sum   :=   1  for   sum     1000   { \n     sum   +=   sum  }    分号只能都要，或者都不要  下面这2种是错的  for   ;   sum     1000   { \n     sum   +=   sum  }   或  for   sum     1000 ;   { \n     sum   +=   sum  }", 
            "title": "简写格式"
        }, 
        {
            "location": "/flow/for/#_3", 
            "text": "for   {  }", 
            "title": "死循环"
        }, 
        {
            "location": "/flow/for/#range", 
            "text": "结合range可以对slice、map、数组、字符串等进行迭代循环  for   key ,   value   :=   range   oldMap   { \n     newMap [ key ]   =   value  }   比如：  func   main ()   { \n     numbers   :=   [ 6 ] int { 1 ,   2 ,   3 ,   5 } \n\n     for   i ,   x   :=   range   numbers   { \n         fmt . Printf ( 第 %d 位 x 的值 = %d\\n ,   i ,   x ) \n     }  }   点击查看 range详解", 
            "title": "结合range"
        }, 
        {
            "location": "/flow/for/#_4", 
            "text": "以下均为个人理解，不保证准确性    for的init statement里声明的变量，以及代码块里声明的变量，都仅限于for里，在外部是无法引用的  例子 package   main  import   fmt  func   main ()   { \n     for   i   :=   0 ;   i     2 ;   i   ++   { \n         fmt . Println ( i ) \n         a   :=   100 \n     } \n     fmt . Println ( i ) \n     fmt . Println ( a )  }   报错 ./for.go:10: undefined: i\n./for.go:11: undefined: a    每次循环都是一个新的空间，即在第一次循环时候声明的变量，在下一次循环时候是看不到的  例子 package   main  import   fmt  func   main ()   { \n     var   a   int   =   100 \n     fmt . Println ( a ) \n\n     fmt . Println ( ===== ) \n     for   i   :=   0 ;   i     2 ;   i   ++   { \n         fmt . Println ( --- ) \n         a   +=   1 \n         fmt . Println ( a ) \n         a   :=   200 \n         fmt . Println ( a ) \n         a   +=   1 \n         fmt . Println ( a ) \n     } \n     fmt . Println ( ===== ) \n\n     fmt . Println ( a )  }   输出 100\n=====\n---\n101\n200\n201\n---\n102\n200\n201\n=====\n102  可以看到每次循环时候a都是200，而不会传递到下次循环中", 
            "title": "作用域"
        }, 
        {
            "location": "/flow/if/", 
            "text": "基本格式\n\n\n\n\nif\n \nx\n \n \n0\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n支持\n\n\nif\n \nx\n \n \n0\n \n{\n\n    \n...\n\n\n}\n \nelse\n \nif\n \nx\n \n \n0\n \n{\n\n    \n...\n\n\n}\n \nelse\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n短声明\n\n\n\n\nif\n \nv\n \n:=\n \nmath\n.\nPow\n(\nx\n,\n \nn\n);\n \nv\n \n \nlim\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n\n\nv是局部变量，只在if语句里有效（包括else）\n\n\n\n\n并不是必须要用短声明\n:=\n，比如下面这样也是可以的\n\n\nvar\n \na\n \nint\n\n\nif\n \na\n \n=\n \n1\n;\n \na\n \n \n2\n \n{\n\n    \nfmt\n.\nPrintln\n(\nyes\n)\n\n\n}\n\n\n\n\n\n\n\n注意\n\n\n无论a \n 2是否为true，a = 1都被执行了。因此谨慎在if条件句里引用外部变量做动作\n\n\n\n\nelse if\n也可以带短声明，但\nelse\n不能带短声明\n\n\nif\n \nx\n \n:=\n \n0\n;\n \na\n \n \n0\n \n{\n\n    \n...\n\n\n}\n \nelse\n \nif\n \nx\n \n:=\n \n1\n;\n \na\n \n \n0\n \n{\n\n    \n...\n\n\n}\n \nelse\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\nif 条件可以用bool值，比如\n\n\nif\n \ntrue\n \n{\n\n    \n...\n\n\n}\n\n\n\n\n\n作用域\n\n\n\n\n例1. if的代码块是独立的作用域吗?\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n1\n\n    \nb\n \n:=\n \n2\n\n\n    \nif\n \n1\n \n \n0\n \n{\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n        \na\n \n=\n \n10\n\n        \nb\n \n=\n \n20\n\n        \na\n \n:=\n \n100\n\n        \nb\n \n:=\n \n200\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n\n}\n\n\n\n\n输出\na: 1\nb: 2\na: 100\nb: 200\na: 10\nb: 20\n\n\n\n答: if的代码块是独立的作用域\n例2. if条件使用短声明时是独立的变量还是引用外部变量?\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n1\n\n    \nb\n \n:=\n \n2\n\n\n    \nif\n \na\n \n:=\n \n10000\n;\n \n1\n \n \n0\n \n{\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n        \na\n \n=\n \n10\n\n        \nb\n \n=\n \n20\n\n        \na\n \n:=\n \n100\n\n        \nb\n \n:=\n \n200\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n\n}\n\n\n\n\n输出\na: 10000\nb: 2\na: 100\nb: 200\na: 1\nb: 20\n\n\n\n答: if条件使用短声明时是独立的变量。下面这个例子更能说明\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nb\n \n:=\n \n2\n\n\n    \nif\n \na\n \n:=\n \n10000\n;\n \n1\n \n \n0\n \n{\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n        \na\n \n=\n \n10\n\n        \nb\n \n=\n \n20\n\n        \na\n \n:=\n \n100\n\n        \nb\n \n:=\n \n200\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n\n}\n\n\n\n\n报错\n./if.go:19: undefined: a\n\n\n\n在if外引用变量a，提示未找到，因为a只在if作用域\n例3. if条件使用赋值语句时是独立的变量还是引用外部变量?\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n1\n\n    \nb\n \n:=\n \n2\n\n\n    \nif\n \na\n \n=\n \n10000\n;\n \n1\n \n \n0\n \n{\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n        \na\n \n=\n \n10\n\n        \nb\n \n=\n \n20\n\n        \na\n \n:=\n \n100\n\n        \nb\n \n:=\n \n200\n\n        \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n\n}\n\n\n\n\n输出\na: 10000\nb: 2\na: 100\nb: 200\na: 10\nb: 20\n\n\n\n答: if条件使用赋值语句时是引用外部变量\n例4. 若if条件不满足，那么条件句里的赋值语句是否有生效?\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n1\n\n    \nb\n \n:=\n \n2\n\n\n    \nif\n \na\n \n=\n \n10000\n;\n \nfalse\n \n{\n\n        \nfmt\n.\nPrintln\n(\nif-a:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nif-b:\n,\n \nb\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n\n}\n\n\n\n\n输出\na: 10000\nb: 2\n\n\n\n如果有else if呢\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n1\n\n    \nb\n \n:=\n \n2\n\n\n    \nif\n \na\n \n=\n \n10\n;\n \nfalse\n \n{\n\n        \nfmt\n.\nPrintln\n(\nif-a:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nif-b:\n,\n \nb\n)\n\n    \n}\n \nelse\n \nif\n \na\n \n=\n \n20\n;\n \ntrue\n \n{\n\n        \nfmt\n.\nPrintln\n(\nif-a:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nif-b:\n,\n \nb\n)\n\n    \n}\n \nelse\n \nif\n \na\n \n=\n \n30\n;\n \nfalse\n \n{\n\n        \nfmt\n.\nPrintln\n(\nif-a:\n,\n \na\n)\n\n        \nfmt\n.\nPrintln\n(\nif-b:\n,\n \nb\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na:\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n)\n\n\n}\n\n\n\n\n输出\nif-a: 20\nif-b: 2\na: 20\nb: 2\n\n\n\n答: 若if条件不满足，那么条件句里的赋值语句依然生效。若有else if，则会依次执行，直到匹配到为止，因此谨慎在if条件句里引用外部变量。", 
            "title": "2. if"
        }, 
        {
            "location": "/flow/if/#_1", 
            "text": "if   x     0   { \n     ...  }   支持  if   x     0   { \n     ...  }   else   if   x     0   { \n     ...  }   else   { \n     ...  }", 
            "title": "基本格式"
        }, 
        {
            "location": "/flow/if/#_2", 
            "text": "if   v   :=   math . Pow ( x ,   n );   v     lim   { \n     ...  }    v是局部变量，只在if语句里有效（包括else）   并不是必须要用短声明 := ，比如下面这样也是可以的  var   a   int  if   a   =   1 ;   a     2   { \n     fmt . Println ( yes )  }    注意  无论a   2是否为true，a = 1都被执行了。因此谨慎在if条件句里引用外部变量做动作   else if 也可以带短声明，但 else 不能带短声明  if   x   :=   0 ;   a     0   { \n     ...  }   else   if   x   :=   1 ;   a     0   { \n     ...  }   else   { \n     ...  }   if 条件可以用bool值，比如  if   true   { \n     ...  }", 
            "title": "短声明"
        }, 
        {
            "location": "/flow/if/#_3", 
            "text": "例1. if的代码块是独立的作用域吗? package   main  import   fmt  func   main ()   { \n     a   :=   1 \n     b   :=   2 \n\n     if   1     0   { \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n         a   =   10 \n         b   =   20 \n         a   :=   100 \n         b   :=   200 \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n     } \n\n     fmt . Println ( a: ,   a ) \n     fmt . Println ( b: ,   b )  }   输出 a: 1\nb: 2\na: 100\nb: 200\na: 10\nb: 20  答: if的代码块是独立的作用域 例2. if条件使用短声明时是独立的变量还是引用外部变量? package   main  import   fmt  func   main ()   { \n     a   :=   1 \n     b   :=   2 \n\n     if   a   :=   10000 ;   1     0   { \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n         a   =   10 \n         b   =   20 \n         a   :=   100 \n         b   :=   200 \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n     } \n\n     fmt . Println ( a: ,   a ) \n     fmt . Println ( b: ,   b )  }   输出 a: 10000\nb: 2\na: 100\nb: 200\na: 1\nb: 20  答: if条件使用短声明时是独立的变量。下面这个例子更能说明 package   main  import   fmt  func   main ()   { \n     b   :=   2 \n\n     if   a   :=   10000 ;   1     0   { \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n         a   =   10 \n         b   =   20 \n         a   :=   100 \n         b   :=   200 \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n     } \n\n     fmt . Println ( a: ,   a ) \n     fmt . Println ( b: ,   b )  }   报错 ./if.go:19: undefined: a  在if外引用变量a，提示未找到，因为a只在if作用域 例3. if条件使用赋值语句时是独立的变量还是引用外部变量? package   main  import   fmt  func   main ()   { \n     a   :=   1 \n     b   :=   2 \n\n     if   a   =   10000 ;   1     0   { \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n         a   =   10 \n         b   =   20 \n         a   :=   100 \n         b   :=   200 \n         fmt . Println ( a: ,   a ) \n         fmt . Println ( b: ,   b ) \n     } \n\n     fmt . Println ( a: ,   a ) \n     fmt . Println ( b: ,   b )  }   输出 a: 10000\nb: 2\na: 100\nb: 200\na: 10\nb: 20  答: if条件使用赋值语句时是引用外部变量 例4. 若if条件不满足，那么条件句里的赋值语句是否有生效? package   main  import   fmt  func   main ()   { \n     a   :=   1 \n     b   :=   2 \n\n     if   a   =   10000 ;   false   { \n         fmt . Println ( if-a: ,   a ) \n         fmt . Println ( if-b: ,   b ) \n     } \n\n     fmt . Println ( a: ,   a ) \n     fmt . Println ( b: ,   b )  }   输出 a: 10000\nb: 2  如果有else if呢 package   main  import   fmt  func   main ()   { \n     a   :=   1 \n     b   :=   2 \n\n     if   a   =   10 ;   false   { \n         fmt . Println ( if-a: ,   a ) \n         fmt . Println ( if-b: ,   b ) \n     }   else   if   a   =   20 ;   true   { \n         fmt . Println ( if-a: ,   a ) \n         fmt . Println ( if-b: ,   b ) \n     }   else   if   a   =   30 ;   false   { \n         fmt . Println ( if-a: ,   a ) \n         fmt . Println ( if-b: ,   b ) \n     } \n\n     fmt . Println ( a: ,   a ) \n     fmt . Println ( b: ,   b )  }   输出 if-a: 20\nif-b: 2\na: 20\nb: 2  答: 若if条件不满足，那么条件句里的赋值语句依然生效。若有else if，则会依次执行，直到匹配到为止，因此谨慎在if条件句里引用外部变量。", 
            "title": "作用域"
        }, 
        {
            "location": "/flow/switch/", 
            "text": "跟变量\n\n\n\n\n某个变量等于A或者等于B\n\n\nswitch\n \nvarA\n \n{\n\n\ncase\n \n0\n:\n\n    \n...\n\n\ncase\n \n1\n:\n\n    \n...\n\n\ndefault\n:\n\n    \n...\n\n\n}\n\n\n\n\n\n不跟变量\n\n\n\n\n相当于if-else if-else if-else\n\n\nswitch\n \n{\n\n\ncase\n \nvarA\n \n \n2\n:\n\n    \n...\n\n\ncase\n \nvarA\n \n \n0\n:\n\n    \n...\n\n\ndefault\n:\n\n    \n...\n\n\n}\n\n\n\n\n\nswitch { ... }\n 等同于 \nswitch true { ... }\n\n\n短声明\n\n\n\n\n2种短声明形式：\n\n\n\n\n\n\n跟变量\n\n\nswitch\n \nos\n \n:=\n \nruntime\n.\nGOOS\n;\n \nos\n \n{\n\n\ncase\n \ndarwin\n:\n\n    \nfmt\n.\nPrintln\n(\nOS X.\n)\n\n\ncase\n \nlinux\n:\n\n    \nfmt\n.\nPrintln\n(\nLinux.\n)\n\n\ndefault\n:\n\n    \nfmt\n.\nPrintf\n(\n%s.\n,\n \nos\n)\n\n\n}\n\n\n\n\n\n\n\nos变量作用域只在switch里\n\n\n\n\n\n\n\n\n不跟变量：\n\n\nswitch\n \nvarA\n \n:=\n \n5\n;\n \n{\n \n//注意这里有个分号，如果没有分号会报错\n\n\ncase\n \nvarA\n \n \n5\n:\n\n    \nfmt\n.\nPrintln\n(\n5\n)\n\n\ncase\n \nvarA\n \n==\n \n5\n:\n\n    \nfmt\n.\nPrintln\n(\n==5\n)\n\n\ncase\n \nvarA\n \n \n5\n:\n\n    \nfmt\n.\nPrintln\n(\n5\n)\n\n\n}\n\n\n\n\n\n\n\n\n\n就是说switch分号后面如果是一个变量，则case就是判断这个变量值等于多少，如果分号后面没变量，则case写条件句，当true时触发\n\n\n注意: case里不能用短声明或赋值语句\n\n\n作用域\n\n\n\n\n例1. switch的短声明是独立的作用域吗?\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n3\n\n\n    \nswitch\n \na\n \n:=\n \n5\n;\n \n{\n \n//注意这里有个分号，如果没有分号会报错\n\n    \ncase\n \na\n \n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n5\n)\n\n    \ncase\n \na\n \n==\n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n==5\n)\n\n    \ncase\n \na\n \n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n5\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n}\n\n\n\n\n输出\n==5\n3\n\n\n\n答: switch的短声明是独立的作用域\n例2. switch的每个case均是独立的作用域吗?\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ni\n \n:=\n \n1\n\n\n    \nswitch\n \na\n \n:=\n \n5\n;\n \n{\n \n//注意这里有个分号，如果没有分号会报错\n\n    \ncase\n \na\n \n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n5\n)\n\n        \ni\n \n:=\n \n2\n\n        \nfmt\n.\nPrintln\n(\ni\n)\n\n    \ncase\n \na\n \n==\n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n==5\n)\n\n        \ni\n \n:=\n \n3\n\n        \nfmt\n.\nPrintln\n(\ni\n)\n\n    \ncase\n \na\n \n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n5\n)\n\n        \ni\n \n:=\n \n4\n\n        \nfmt\n.\nPrintln\n(\ni\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\ni\n)\n\n\n}\n\n\n\n\n输出\n==5\n3\n1\n\n\n\n答: switch的每个case均是独立的作用域\n例3. switch使用赋值语句时是独立变量还是引用外部变量?\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n3\n\n\n    \nswitch\n \na\n \n=\n \n5\n;\n \n{\n \n//注意这里有个分号，如果没有分号会报错\n\n    \ncase\n \na\n \n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n5\n)\n\n    \ncase\n \na\n \n==\n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n==5\n)\n\n    \ncase\n \na\n \n \n5\n:\n\n        \nfmt\n.\nPrintln\n(\n5\n)\n\n    \n}\n\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n}\n\n\n\n\n输出\n==5\n5\n\n\n\n答: switch使用赋值语句时是引用外部变量", 
            "title": "3. switch"
        }, 
        {
            "location": "/flow/switch/#_1", 
            "text": "某个变量等于A或者等于B  switch   varA   {  case   0 : \n     ...  case   1 : \n     ...  default : \n     ...  }", 
            "title": "跟变量"
        }, 
        {
            "location": "/flow/switch/#_2", 
            "text": "相当于if-else if-else if-else  switch   {  case   varA     2 : \n     ...  case   varA     0 : \n     ...  default : \n     ...  }   switch { ... }  等同于  switch true { ... }", 
            "title": "不跟变量"
        }, 
        {
            "location": "/flow/switch/#_3", 
            "text": "2种短声明形式：    跟变量  switch   os   :=   runtime . GOOS ;   os   {  case   darwin : \n     fmt . Println ( OS X. )  case   linux : \n     fmt . Println ( Linux. )  default : \n     fmt . Printf ( %s. ,   os )  }    os变量作用域只在switch里     不跟变量：  switch   varA   :=   5 ;   {   //注意这里有个分号，如果没有分号会报错  case   varA     5 : \n     fmt . Println ( 5 )  case   varA   ==   5 : \n     fmt . Println ( ==5 )  case   varA     5 : \n     fmt . Println ( 5 )  }     就是说switch分号后面如果是一个变量，则case就是判断这个变量值等于多少，如果分号后面没变量，则case写条件句，当true时触发  注意: case里不能用短声明或赋值语句", 
            "title": "短声明"
        }, 
        {
            "location": "/flow/switch/#_4", 
            "text": "例1. switch的短声明是独立的作用域吗? package   main  import   fmt  func   main ()   { \n     a   :=   3 \n\n     switch   a   :=   5 ;   {   //注意这里有个分号，如果没有分号会报错 \n     case   a     5 : \n         fmt . Println ( 5 ) \n     case   a   ==   5 : \n         fmt . Println ( ==5 ) \n     case   a     5 : \n         fmt . Println ( 5 ) \n     } \n\n     fmt . Println ( a )  }   输出 ==5\n3  答: switch的短声明是独立的作用域 例2. switch的每个case均是独立的作用域吗? package   main  import   fmt  func   main ()   { \n     i   :=   1 \n\n     switch   a   :=   5 ;   {   //注意这里有个分号，如果没有分号会报错 \n     case   a     5 : \n         fmt . Println ( 5 ) \n         i   :=   2 \n         fmt . Println ( i ) \n     case   a   ==   5 : \n         fmt . Println ( ==5 ) \n         i   :=   3 \n         fmt . Println ( i ) \n     case   a     5 : \n         fmt . Println ( 5 ) \n         i   :=   4 \n         fmt . Println ( i ) \n     } \n\n     fmt . Println ( i )  }   输出 ==5\n3\n1  答: switch的每个case均是独立的作用域 例3. switch使用赋值语句时是独立变量还是引用外部变量? package   main  import   fmt  func   main ()   { \n     a   :=   3 \n\n     switch   a   =   5 ;   {   //注意这里有个分号，如果没有分号会报错 \n     case   a     5 : \n         fmt . Println ( 5 ) \n     case   a   ==   5 : \n         fmt . Println ( ==5 ) \n     case   a     5 : \n         fmt . Println ( 5 ) \n     } \n\n     fmt . Println ( a )  }   输出 ==5\n5  答: switch使用赋值语句时是引用外部变量", 
            "title": "作用域"
        }, 
        {
            "location": "/flow/defer/", 
            "text": "defer，顾名思义，就是推迟执行的意思\n\n\ndefer使得后面跟的函数在当前函数结束之后执行（如果有return，就是在reutrn之前执行）\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nfunc1\n(\na\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \na\n \n+\n \n1\n\n\n}\n\n\n\nfunc\n \nfunc2\n(\na\n \nint\n)\n \nint\n \n{\n\n    \ndefer\n \nfmt\n.\nPrintln\n(\nfunc1\n(\n100\n))\n\n    \nfmt\n.\nPrintln\n(\naa\n)\n\n    \nreturn\n \na\n \n+\n \n1\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nfunc2\n(\n10\n))\n\n\n}\n\n\n\n\n\n输出\n\n\naa\n101\n11\n\n\n\n\ndefer栈：如果有多个defer，则是从后往前执行\n（原话：延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。），比如：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nfunc1\n(\na\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \na\n \n+\n \n1\n\n\n}\n\n\n\nfunc\n \nfunc2\n(\na\n \nint\n)\n \nint\n \n{\n\n    \ndefer\n \nfmt\n.\nPrintln\n(\nfunc1\n(\n100\n))\n\n    \ndefer\n \nfmt\n.\nPrintln\n(\nfunc1\n(\n200\n))\n\n    \nfmt\n.\nPrintln\n(\naa\n)\n\n    \nreturn\n \na\n \n+\n \n1\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nfunc2\n(\n10\n))\n\n\n}\n\n\n\n\n\n输出\n\n\naa\n201\n101\n11", 
            "title": "4. defer"
        }, 
        {
            "location": "/datatype/pointer/", 
            "text": "声明指针：\n\n\nvar\n \np\n \n*\nint\n\n\np\n \n=\n \ni\n\n\n\n\n\n其他声明方式\nvar\n \np\n \n*\nint\n \n=\n \ni\n\n\n\n\nvar\n \np\n \n=\n \ni\n\n\n\n\np\n \n:=\n \ni\n\n\n\n\n符号会生成指针，如\n\n\ni\n \n:=\n \n42\n\n\np\n \n:=\n \ni\n\n\n\n\n\n*\n符号读取指针指向的值，如\n\n\nfmt\n.\nPrintln\n(\n*\np\n)\n\n\n\n\n\n可以叠加，比如：\n\n\ni\n \n:=\n \n42\n\n\np\n \n:=\n \ni\n\n\nq\n \n:=\n \np\n\n\nfmt\n.\nPrintf\n(\n%T\\n\n,\n \np\n)\n\n\nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nq\n)\n\n\nfmt\n.\nPrintln\n(\n*\np\n)\n\n\nfmt\n.\nPrintln\n(\np\n)\n\n\nfmt\n.\nPrintln\n(\n*\nq\n)\n\n\nfmt\n.\nPrintln\n(\n**\nq\n)\n\n\n\n\n\n输出\n\n\n*int\n**int\n42\n0xc420056168\n0xc420056168\n42\n\n\n\n\n也可以这么叠加，比如：\n\n\nx\n \n:=\n \n42\n\n\np\n \n:=\n \nx\n\n\n*\np\n \n=\n \n11\n\n\n*\n*\np\n \n=\n \n12\n\n\n*\n*\n*\np\n \n=\n \n13\n\n\nfmt\n.\nPrintln\n(\nx\n)\n\n\n\n\n\n输出\n\n\n13", 
            "title": "1. pointer"
        }, 
        {
            "location": "/datatype/struct_main/", 
            "text": "type\n \nvertex\n \nstruct\n \n{\n\n    \nx\n \nint\n\n    \ny\n \nint\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nvertex\n{\n1\n,\n \n2\n})\n   \n//打印整个struct\n\n    \nv\n \n:=\n \nvertex\n{\n1\n,\n \n2\n}\n\n    \nv\n.\nx\n \n=\n \n4\n\n    \nfmt\n.\nPrintln\n(\nv\n.\nx\n)\n            \n//仅打印x这个字段\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nv\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n{1 2}\n4\nmain.vertex", 
            "title": "2.1. 声明"
        }, 
        {
            "location": "/datatype/struct_export/", 
            "text": "首字母大写才可以被其他模块导入引用，包含struct名和其中元素，只有大写的才可被其他模块导入引用。例如\n\n\n\n\n\n\n这样都不能被其他模块引用\n\n\ntype\n \nvertex\n \nstruct\n \n{\n\n    \nx\n \nint\n\n    \ny\n \nint\n\n\n}\n\n\n\n\n\n\n\n\n\n这样只有struct可以被其他模块引用，但是struct中的元素不能被其他模块引用\n\n\ntype\n \nVertex\n \nstruct\n \n{\n\n    \nx\n \nint\n\n    \ny\n \nint\n\n\n}\n\n\n\n\n\n\n\n\n\n这样struct和struct中的元素都可以被其他模块引用\n\n\ntype\n \nVertex\n \nstruct\n \n{\n\n    \nX\n \nint\n\n    \nY\n \nint\n\n\n}", 
            "title": "2.2. 导出名"
        }, 
        {
            "location": "/datatype/struct_pointer/", 
            "text": "type\n \nVertex\n \nstruct\n \n{\n\n    \nX\n \nint\n\n    \nY\n \nint\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nv\n \n:=\n \nVertex\n{\n1\n,\n \n2\n}\n\n    \np\n \n:=\n \nv\n\n    \np\n.\nX\n \n=\n \n1e9\n\n    \nfmt\n.\nPrintln\n(\nv\n)\n\n\n}\n\n\n\n\n\np.X\n原本应该写成\n(*p).X\n，但golang支持\np.X\n这样写法，因此这2种写法的效果是一样的", 
            "title": "2.3. struct指针"
        }, 
        {
            "location": "/datatype/struct_literal/", 
            "text": "type\n \nVertex\n \nstruct\n \n{\n\n    \nX\n,\n \nY\n \nint\n\n\n}\n\n\n\nvar\n \n(\n\n    \nv1\n \n=\n \nVertex\n{\n1\n,\n \n2\n}\n  \n// has type Vertex\n\n    \nv2\n \n=\n \nVertex\n{\nX\n:\n \n1\n}\n  \n// Y:0 is implicit\n\n    \nv3\n \n=\n \nVertex\n{}\n      \n// X:0 and Y:0\n\n    \np\n  \n=\n \nVertex\n{\n1\n,\n \n2\n}\n \n// has type *Vertex\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nv1\n,\n \np\n,\n \nv2\n,\n \nv3\n)\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \np\n)\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \n*\np\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n{1 2} \n{1 2} {1 0} {0 0}\n*main.Vertex\nmain.Vertex\n\n\n\n\n\n\nNote\n\n\n\n\n声明多个变量时候可以用\nvar (...)\n\n\nv2 = Vertex{X: 1}\n这样表示X为1，其他都为类型推导的默认值\n\n\n这里struct指针类型是\n*main.Vertex", 
            "title": "2.4. literal"
        }, 
        {
            "location": "/datatype/struct_anon/", 
            "text": "如果只是临时使用struct一次，而不是多次使用，用匿名struct即可\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nstruct\n{\nname\n \nstring\n}{\nname\n:\n \nhello\n}\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \na\n)\n\n    \nfmt\n.\nPrintf\n(\n%v\\n\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\na\n.\nname\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nstruct { name string }\n{hello}\nhello", 
            "title": "2.5. 匿名struct"
        }, 
        {
            "location": "/datatype/arr_sli_main/", 
            "text": "在golang中有array（数组）和slice（切片）关系紧密，因此放在一个章节里阐述\n\n\n下面将array和slice从不同维度进行比较\n\n\n声明赋值\n\n\n\n\narray\n\n\narr\n \n:=\n \n[\n6\n]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n\n\n\n\nslice\n\n\nsli\n \n:=\n \narr\n[\n1\n:\n4\n]\n\n\n\n\n\n\n\narr[1:4]就是对arr做的切片\n\n\n\n\n本质\n\n\n\n\narray就是array\n\n\nslice是array元素的引用，官方把slice叫做underlying array、Slices are like references to arrays\n\n\n\n\n从使用效果上看，slice完全就像是array元素的指针\n\n\n\n\n用函数传递例子更可以看出区别：slice传递的是地址，效果和指针相同，而array是复制元素\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \narrDo\n(\nx\n \n[\n6\n]\nint\n)\n \n{\n\n    \nx\n[\n2\n]\n \n=\n \n333\n\n\n}\n\n\n\nfunc\n \nsliDo\n(\nx\n \n[]\nint\n)\n \n{\n\n    \nx\n[\n2\n]\n \n=\n \n333\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \narr\n \n:=\n \n[\n6\n]\nint\n{\n11\n,\n \n22\n,\n \n33\n,\n \n44\n,\n \n55\n,\n \n66\n}\n\n    \nsli\n \n:=\n \n[]\nint\n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n,\n \n6\n}\n\n\n    \narrDo\n(\narr\n)\n\n    \nsliDo\n(\nsli\n)\n\n\n    \nfmt\n.\nPrintln\n(\narr:\n,\n \narr\n)\n\n    \nfmt\n.\nPrintln\n(\nsli:\n,\n \nsli\n)\n\n\n}\n\n\n\n\n\n输出\n\n\narr: [11 22 33 44 55 66]\nsli: [1 2 333 4 5 6]\n\n\n\n\n可以看出通过函数传递的array，在函数里把值修改后在函数外看不到。而slice是可以看到\n\n\n长度是否可变\n\n\n\n\narray是固定长度，占用内存中固定的一块地址，因此不可能删除array元素来导致长度变化\n\n\nslice是可变长度，内存地址可扩展\n\n\n2种声明方式\n\n\n\n\narray\n\n\n\n\n\n\n普通方式：\n\n\n//显式声明数组arr，长度为6，元素类型为int\n\n\nvar\n \narr\n \n[\n6\n]\nint\n\n\narr\n[\n0\n]\n \n=\n \n2\n\n\narr\n[\n1\n]\n \n=\n \n3\n\n\narr\n[\n2\n]\n \n=\n \n5\n\n\narr\n[\n3\n]\n \n=\n \n7\n\n\narr\n[\n4\n]\n \n=\n \n11\n\n\narr\n[\n5\n]\n \n=\n \n13\n\n\n\n\n\n\n\n\n\nliteral方式：\n\n\narr\n \n:=\n \n[\n6\n]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n\n\n\n\n\n\n\n\nslice\n\n\n\n\n\n\n普通方式：\n\n\n//显式声明切片sli，其中可见元素为arr的第2个元素地址到第4个元素地址，但容量为第2个元素地址到最后一个元素地址\n\n\nvar\n \nsli\n \n[]\nint\n \n=\n \narr\n[\n1\n:\n4\n]\n\n\n\n\n\n\n\n\n\nliteral方式：\n\n\nsli := []int{2, 3, 5, 7, 11, 13}\n\n\n\n\n\n\n\n\n类型\n\n\n\n\narray的类型示例：[6]int\n\n\nslice的类型示例：[]int\n\n\n因此slice也叫做数组类型（这个忘了为啥叫数组类型）", 
            "title": "3.1. 介绍与比较"
        }, 
        {
            "location": "/datatype/arr_sli_main/#_1", 
            "text": "array  arr   :=   [ 6 ] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 }   slice  sli   :=   arr [ 1 : 4 ]    arr[1:4]就是对arr做的切片", 
            "title": "声明赋值"
        }, 
        {
            "location": "/datatype/arr_sli_main/#_2", 
            "text": "array就是array  slice是array元素的引用，官方把slice叫做underlying array、Slices are like references to arrays   从使用效果上看，slice完全就像是array元素的指针   用函数传递例子更可以看出区别：slice传递的是地址，效果和指针相同，而array是复制元素  package   main  import   fmt  func   arrDo ( x   [ 6 ] int )   { \n     x [ 2 ]   =   333  }  func   sliDo ( x   [] int )   { \n     x [ 2 ]   =   333  }  func   main ()   { \n     arr   :=   [ 6 ] int { 11 ,   22 ,   33 ,   44 ,   55 ,   66 } \n     sli   :=   [] int { 1 ,   2 ,   3 ,   4 ,   5 ,   6 } \n\n     arrDo ( arr ) \n     sliDo ( sli ) \n\n     fmt . Println ( arr: ,   arr ) \n     fmt . Println ( sli: ,   sli )  }   输出  arr: [11 22 33 44 55 66]\nsli: [1 2 333 4 5 6]  可以看出通过函数传递的array，在函数里把值修改后在函数外看不到。而slice是可以看到", 
            "title": "本质"
        }, 
        {
            "location": "/datatype/arr_sli_main/#_3", 
            "text": "array是固定长度，占用内存中固定的一块地址，因此不可能删除array元素来导致长度变化  slice是可变长度，内存地址可扩展", 
            "title": "长度是否可变"
        }, 
        {
            "location": "/datatype/arr_sli_main/#2", 
            "text": "array    普通方式：  //显式声明数组arr，长度为6，元素类型为int  var   arr   [ 6 ] int  arr [ 0 ]   =   2  arr [ 1 ]   =   3  arr [ 2 ]   =   5  arr [ 3 ]   =   7  arr [ 4 ]   =   11  arr [ 5 ]   =   13     literal方式：  arr   :=   [ 6 ] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 }     slice    普通方式：  //显式声明切片sli，其中可见元素为arr的第2个元素地址到第4个元素地址，但容量为第2个元素地址到最后一个元素地址  var   sli   [] int   =   arr [ 1 : 4 ]     literal方式：  sli := []int{2, 3, 5, 7, 11, 13}", 
            "title": "2种声明方式"
        }, 
        {
            "location": "/datatype/arr_sli_main/#_4", 
            "text": "array的类型示例：[6]int  slice的类型示例：[]int  因此slice也叫做数组类型（这个忘了为啥叫数组类型）", 
            "title": "类型"
        }, 
        {
            "location": "/datatype/arr_sli_len_cap/", 
            "text": "有2个很重要的内置函数：\nlen()\n和\ncap()\n\n\nlen()\n可以用来查看数组或slice的长度\n\n\ncap()\n可以用来查看数组或slice的容量\n\n\n在数组中由于长度固定不可变，因此\nlen(arr)\n和\ncap(arr)\n的输出永远相同\n\n\n在slice中，\nlen(sli)\n表示可见元素有几个（也即直接打印元素看到的元素个数），而\ncap(sli)\n表示所有元素有几个，比如：\n\n\narr\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n\nsli\n \n:=\n \narr\n[\n1\n:\n4\n]\n\n\nfmt\n.\nPrintln\n(\nsli\n)\n\n\nfmt\n.\nPrintln\n(\nlen\n(\nsli\n))\n\n\nfmt\n.\nPrintln\n(\ncap\n(\nsli\n))\n\n\n\n\n\n输出\n\n\n[3 5 7]\n3\n5\n\n\n\n\n查看一共有几个元素的方法：\n\n\nfmt\n.\nPrintln\n(\nsli\n[:\ncap\n(\nsli\n)])\n\n\n\n\n\n输出\n\n\n[3 5 7 11 13]\n\n\n\n\n这样查看有个好处就是对sli没有影响，包括元素内容、len、cap", 
            "title": "3.2. len()与cap()"
        }, 
        {
            "location": "/datatype/arr_sli_index/", 
            "text": "startIndex和endIndex\n\n\n\n\n[startIndex:endIndex]\n\n\n表示的是从第startIndex下标的元素开始，直到endIndex-1下标的元素结束。\n\n\n其中元素下标是从0开始计数。如果用通俗的话来记忆就是从第startIndex+1开始，到第endIndex结束。\n\n\n注意：这里的endIndex是指可见元素到哪为止，即影响len()，\n而不影响cap()，其中cap()都是到最后一个元素\n\n\n下标举例说明\n\n\n\n\n\n\n\n\n[1:5] 从第二个元素开始（0为第一个元素，1为第二个元素），取到第5个元素（下标为5-1=4，下标4表示第5个元素）出来，同时删除第一个元素，但cap依然是到最后一个元素\n\n\n\n\n\n\n[:] 取所有元素，没有删除元素\n\n\n\n\n\n\n[1:] 从第二个元素开始取所有元素，同时删除第一个元素\n\n\n\n\n\n\n[:5] 等同于[0:5]，即从第一个元素开始，取到第5个元素出来，但cap依然是到最后一个元素\n\n\n\n\n\n\n下标边界写法\n\n\n\n\n首先说下，边界这2个字是我自己取的\n\n\n若声明一个变量\nvar a [10]int\n，则下面的语句是相同的\n\n\na[0:10]\na[:10]\na[0:]\na[:]\na[:cap(a)]\n\n\n\n\n举例如下:\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \narr\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n    \nsli1\n \n:=\n \narr\n[\n1\n:\n4\n]\n\n    \nfmt\n.\nPrintln\n(\n[1:4]\n,\n \nsli1\n)\n\n    \nfmt\n.\nPrintln\n(\n[1:4]\n,\n \nlen\n(\nsli1\n))\n\n    \nfmt\n.\nPrintln\n(\n[1:4]\n,\n \ncap\n(\nsli1\n))\n\n    \nfmt\n.\nPrintln\n(\n-----\n)\n\n    \nsli2\n \n:=\n \narr\n[\n1\n:\n3\n]\n\n    \nfmt\n.\nPrintln\n(\n[1:3]\n,\n \nsli2\n)\n\n    \nfmt\n.\nPrintln\n(\n[1:3]\n,\n \nlen\n(\nsli2\n))\n\n    \nfmt\n.\nPrintln\n(\n[1:3]\n,\n \ncap\n(\nsli2\n))\n\n    \nfmt\n.\nPrintln\n(\n-----\n)\n\n    \nsli3\n \n:=\n \narr\n[\n1\n:\n2\n]\n\n    \nfmt\n.\nPrintln\n(\n[1:2]\n,\n \nsli3\n)\n\n    \nfmt\n.\nPrintln\n(\n[1:2]\n,\n \nlen\n(\nsli3\n))\n\n    \nfmt\n.\nPrintln\n(\n[1:2]\n,\n \ncap\n(\nsli3\n))\n\n    \nfmt\n.\nPrintln\n(\n-----\n)\n\n    \nsli4\n \n:=\n \narr\n[\n1\n:\n1\n]\n\n    \nfmt\n.\nPrintln\n(\n[1:1]\n,\n \nsli4\n)\n\n    \nfmt\n.\nPrintln\n(\n[1:1]\n,\n \nlen\n(\nsli4\n))\n\n    \nfmt\n.\nPrintln\n(\n[1:1]\n,\n \ncap\n(\nsli4\n))\n\n\n}\n\n\n\n\n\n输出\n\n\n[1:4] [3 5 7]\n[1:4] 3\n[1:4] 5\n-----\n[1:3] [3 5]\n[1:3] 2\n[1:3] 5\n-----\n[1:2] [3]\n[1:2] 1\n[1:2] 5\n-----\n[1:1] []\n[1:1] 0\n[1:1] 5\n\n\n\n\n当endIndex超出边界时候则会报错\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \narr\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n    \nsli1\n \n:=\n \narr\n[\n1\n:\n0\n]\n\n    \nfmt\n.\nPrintln\n(\n[1:0]\n,\n \nsli1\n)\n\n    \nfmt\n.\nPrintln\n(\n[1:0]\n,\n \nlen\n(\nsli1\n))\n\n    \nfmt\n.\nPrintln\n(\n[1:0]\n,\n \ncap\n(\nsli1\n))\n\n\n}\n\n\n\n\n\n报错\n\n\n./slice.go:7: invalid slice index: 1 \n 0", 
            "title": "3.3. 下标"
        }, 
        {
            "location": "/datatype/arr_sli_index/#startindexendindex", 
            "text": "[startIndex:endIndex]  表示的是从第startIndex下标的元素开始，直到endIndex-1下标的元素结束。  其中元素下标是从0开始计数。如果用通俗的话来记忆就是从第startIndex+1开始，到第endIndex结束。  注意：这里的endIndex是指可见元素到哪为止，即影响len()， 而不影响cap()，其中cap()都是到最后一个元素", 
            "title": "startIndex和endIndex"
        }, 
        {
            "location": "/datatype/arr_sli_index/#_1", 
            "text": "[1:5] 从第二个元素开始（0为第一个元素，1为第二个元素），取到第5个元素（下标为5-1=4，下标4表示第5个元素）出来，同时删除第一个元素，但cap依然是到最后一个元素    [:] 取所有元素，没有删除元素    [1:] 从第二个元素开始取所有元素，同时删除第一个元素    [:5] 等同于[0:5]，即从第一个元素开始，取到第5个元素出来，但cap依然是到最后一个元素", 
            "title": "下标举例说明"
        }, 
        {
            "location": "/datatype/arr_sli_index/#_2", 
            "text": "首先说下，边界这2个字是我自己取的  若声明一个变量 var a [10]int ，则下面的语句是相同的  a[0:10]\na[:10]\na[0:]\na[:]\na[:cap(a)]  举例如下:  package   main  import   fmt  func   main ()   { \n     arr   :=   [] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 } \n     sli1   :=   arr [ 1 : 4 ] \n     fmt . Println ( [1:4] ,   sli1 ) \n     fmt . Println ( [1:4] ,   len ( sli1 )) \n     fmt . Println ( [1:4] ,   cap ( sli1 )) \n     fmt . Println ( ----- ) \n     sli2   :=   arr [ 1 : 3 ] \n     fmt . Println ( [1:3] ,   sli2 ) \n     fmt . Println ( [1:3] ,   len ( sli2 )) \n     fmt . Println ( [1:3] ,   cap ( sli2 )) \n     fmt . Println ( ----- ) \n     sli3   :=   arr [ 1 : 2 ] \n     fmt . Println ( [1:2] ,   sli3 ) \n     fmt . Println ( [1:2] ,   len ( sli3 )) \n     fmt . Println ( [1:2] ,   cap ( sli3 )) \n     fmt . Println ( ----- ) \n     sli4   :=   arr [ 1 : 1 ] \n     fmt . Println ( [1:1] ,   sli4 ) \n     fmt . Println ( [1:1] ,   len ( sli4 )) \n     fmt . Println ( [1:1] ,   cap ( sli4 ))  }   输出  [1:4] [3 5 7]\n[1:4] 3\n[1:4] 5\n-----\n[1:3] [3 5]\n[1:3] 2\n[1:3] 5\n-----\n[1:2] [3]\n[1:2] 1\n[1:2] 5\n-----\n[1:1] []\n[1:1] 0\n[1:1] 5  当endIndex超出边界时候则会报错  package   main  import   fmt  func   main ()   { \n     arr   :=   [] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 } \n     sli1   :=   arr [ 1 : 0 ] \n     fmt . Println ( [1:0] ,   sli1 ) \n     fmt . Println ( [1:0] ,   len ( sli1 )) \n     fmt . Println ( [1:0] ,   cap ( sli1 ))  }   报错  ./slice.go:7: invalid slice index: 1   0", 
            "title": "下标边界写法"
        }, 
        {
            "location": "/datatype/arr_sli_key/", 
            "text": "slice原理\n\n\n\n\n\n\n\n\n在切片时候仅仅把原来元素的地址给拷贝过来了，即有当元素的值发生改变的时候，之前和之后引用的slice都可以看到变化\n\n\n\n\n\n\n一个slice中元素被删掉后不会影响其他slice。比如有3个slice都是来自同一个array或者slice，那么当这个slice的元素被删掉后，那3个slice和原来的array不受影响。应该是当那个元素被删掉后，go发现有被引用了，于是内存中并没有去删掉，因此那3个slice才不受影响，但是那3个slice的元素依然是来自原来的地址\n\n\n\n\n\n\n\n\npython不是引用，而是复制\n\n\n#!/usr/bin/env python\n\n\n# -*- coding: utf-8 -*-\n\n\n\narr\n \n=\n \n[\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n]\n\n\nprint\n \narr\n\n\n\nsli\n \n=\n \narr\n[\n1\n:\n4\n]\n\n\nprint\n \nsli\n\n\n\narr\n[\n1\n]\n \n=\n \n33\n\n\nsli\n[\n2\n]\n \n=\n \n55\n\n\nprint\n \narr\n\n\nprint\n \nsli\n\n\n\n\n\n输出\n\n\n[2, 3, 5, 7, 11, 13]\n[3, 5, 7]\n[2, 33, 5, 7, 11, 13]\n[3, 5, 55]\n\n\n\n\n可以看到，修改arr的元素值没有影响到sli，同样，修改sli的元素值也没有影响到arr\n\n\n\n\n关于literal\n\n\n\n\n\n\n\n\n即使原来slice已经声明了，依然可以用literal赋值，但类型必须是和声明时候相同类型\n\n\n\n\n\n\n用literal赋值后（即使赋的值和原来的值一样），所有元素都是新的了，和原来没有关系了，如果原来有关联的slice，那么关联就解除了\n\n\n\n\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nsli1\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n    \nsli2\n \n:=\n \nsli1\n[\n1\n:\n4\n]\n\n    \nfmt\n.\nPrintln\n(\nsli1\n,\n \nlen\n(\nsli1\n),\n \ncap\n(\nsli1\n))\n\n    \nfmt\n.\nPrintln\n(\nsli2\n,\n \nlen\n(\nsli2\n),\n \ncap\n(\nsli2\n))\n\n\n    \nsli1\n \n=\n \n[]\nint\n{\n20\n,\n \n30\n,\n \n50\n,\n \n70\n,\n \n110\n,\n \n130\n}\n\n    \nsli2\n[\n2\n]\n \n=\n \n500\n\n    \nfmt\n.\nPrintln\n(\nsli1\n,\n \nlen\n(\nsli1\n),\n \ncap\n(\nsli1\n))\n\n    \nfmt\n.\nPrintln\n(\nsli2\n,\n \nlen\n(\nsli2\n),\n \ncap\n(\nsli2\n))\n\n\n}\n\n\n\n\n\n输出\n\n\n[2 3 5 7 11 13] 6 6\n[3 5 7] 3 5\n[20 30 50 70 110 130] 6 6\n[3 5 500] 3 5\n\n\n\n\n关于关联脱离\n\n\n\n\n经测试，如下几种方法可以和array、衍生slice等脱离关联\n\n\n\n\n\n\nliteral赋值\n\n\n\n\n\n\nappend()\n\n\n\n\n\n\ncopy()\n\n\n\n\n\n\n可以被切片的数据类型\n\n\n\n\n\n\n\n\narray\n\n\narr\n \n:=\n \n[\n6\n]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n\nsli\n \n:=\n \narr\n[\n1\n:\n4\n]\n\n\n\n\n\n\n\n\n\nslice\n\n\nsli1\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n\nsli2\n \n:=\n \nsli1\n[\n1\n:\n4\n]\n\n\n\n\n\n\n\n\n\nstring\n\n\nstr\n \n:=\n \nhello, world!\n\n\nsli\n \n:=\n \nstr\n[\n1\n:\n4\n]\n\n\n\n\n\n示例\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nstr\n \n:=\n \nhello, world!\n\n    \nres\n \n:=\n \nstr\n[\n2\n:]\n\n    \nfmt\n.\nPrintln\n(\nstr\n)\n\n    \nfmt\n.\nPrintln\n(\nres\n)\n\n    \nfmt\n.\nPrintln\n(\nstr\n)\n\n\n}\n\n\n\n\n输出\nhello, world!\nllo, world!\nhello, world!", 
            "title": "3.4. 深入理解"
        }, 
        {
            "location": "/datatype/arr_sli_key/#slice", 
            "text": "在切片时候仅仅把原来元素的地址给拷贝过来了，即有当元素的值发生改变的时候，之前和之后引用的slice都可以看到变化    一个slice中元素被删掉后不会影响其他slice。比如有3个slice都是来自同一个array或者slice，那么当这个slice的元素被删掉后，那3个slice和原来的array不受影响。应该是当那个元素被删掉后，go发现有被引用了，于是内存中并没有去删掉，因此那3个slice才不受影响，但是那3个slice的元素依然是来自原来的地址     python不是引用，而是复制  #!/usr/bin/env python  # -*- coding: utf-8 -*-  arr   =   [ 2 ,   3 ,   5 ,   7 ,   11 ,   13 ]  print   arr  sli   =   arr [ 1 : 4 ]  print   sli  arr [ 1 ]   =   33  sli [ 2 ]   =   55  print   arr  print   sli   输出  [2, 3, 5, 7, 11, 13]\n[3, 5, 7]\n[2, 33, 5, 7, 11, 13]\n[3, 5, 55]  可以看到，修改arr的元素值没有影响到sli，同样，修改sli的元素值也没有影响到arr", 
            "title": "slice原理"
        }, 
        {
            "location": "/datatype/arr_sli_key/#literal", 
            "text": "即使原来slice已经声明了，依然可以用literal赋值，但类型必须是和声明时候相同类型    用literal赋值后（即使赋的值和原来的值一样），所有元素都是新的了，和原来没有关系了，如果原来有关联的slice，那么关联就解除了    package   main  import   fmt  func   main ()   { \n     sli1   :=   [] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 } \n     sli2   :=   sli1 [ 1 : 4 ] \n     fmt . Println ( sli1 ,   len ( sli1 ),   cap ( sli1 )) \n     fmt . Println ( sli2 ,   len ( sli2 ),   cap ( sli2 )) \n\n     sli1   =   [] int { 20 ,   30 ,   50 ,   70 ,   110 ,   130 } \n     sli2 [ 2 ]   =   500 \n     fmt . Println ( sli1 ,   len ( sli1 ),   cap ( sli1 )) \n     fmt . Println ( sli2 ,   len ( sli2 ),   cap ( sli2 ))  }   输出  [2 3 5 7 11 13] 6 6\n[3 5 7] 3 5\n[20 30 50 70 110 130] 6 6\n[3 5 500] 3 5", 
            "title": "关于literal"
        }, 
        {
            "location": "/datatype/arr_sli_key/#_1", 
            "text": "经测试，如下几种方法可以和array、衍生slice等脱离关联    literal赋值    append()    copy()", 
            "title": "关于关联脱离"
        }, 
        {
            "location": "/datatype/arr_sli_key/#_2", 
            "text": "array  arr   :=   [ 6 ] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 }  sli   :=   arr [ 1 : 4 ]     slice  sli1   :=   [] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 }  sli2   :=   sli1 [ 1 : 4 ]     string  str   :=   hello, world!  sli   :=   str [ 1 : 4 ]   示例 package   main  import   fmt  func   main ()   { \n     str   :=   hello, world! \n     res   :=   str [ 2 :] \n     fmt . Println ( str ) \n     fmt . Println ( res ) \n     fmt . Println ( str )  }   输出 hello, world!\nllo, world!\nhello, world!", 
            "title": "可以被切片的数据类型"
        }, 
        {
            "location": "/datatype/arr_sli_nil/", 
            "text": "A nil slice has a length and capacity of 0 and has no underlying array.\n\n\n\n\n目前已知只有\nvar s []int\n这1种方法才是nil slice。其他情况都不是，因为\n只有no underlying array才是nil slice\n\n\n下面几种方法都不是nil slice\n\n\n\n\n\n\ns := []int{}\n不是nil\n\n\n\n\n\n\n删除所有元素也不算是nil，如\n\n\nsli\n \n=\n \nsli\n[:\ncap\n(\nsli\n)]\n\n\nsli\n \n=\n \nsli\n[\nlen\n(\nsli\n):]\n\n\n\n\n\n\n\n\n\n用\nmake([]int, 0, 0)\n也不是nil\n\n\n\n\n\n\n实践证明上面的阐述\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \n[]\nint\n\n    \nfmt\n.\nPrintln\n(\na:\n,\n \na\n,\n \nlen\n(\na\n),\n \ncap\n(\na\n))\n\n\n    \nb\n \n:=\n \n[]\nint\n{}\n\n    \nfmt\n.\nPrintln\n(\nb:\n,\n \nb\n,\n \nlen\n(\nb\n),\n \ncap\n(\nb\n))\n\n\n    \nc\n \n:=\n \nmake\n([]\nint\n,\n \n0\n,\n \n0\n)\n\n    \nfmt\n.\nPrintln\n(\nc:\n,\n \nc\n,\n \nlen\n(\nc\n),\n \ncap\n(\nc\n))\n\n\n    \nd\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n    \nd\n \n=\n \nd\n[:\ncap\n(\nd\n)]\n\n    \nd\n \n=\n \nd\n[\nlen\n(\nd\n):]\n\n    \nfmt\n.\nPrintln\n(\nd:\n,\n \nd\n,\n \nlen\n(\nd\n),\n \ncap\n(\nd\n))\n\n\n    \nif\n \na\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\na is nil\n)\n\n    \n}\n\n\n    \nif\n \nb\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\nb is nil\n)\n\n    \n}\n\n\n    \nif\n \nc\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\nc is nil\n)\n\n    \n}\n\n\n    \nif\n \nd\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\nd is nil\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n输出\n\n\na: [] 0 0\nb: [] 0 0\nc: [] 0 0\nd: [] 0 0\na is nil", 
            "title": "3.5. nil"
        }, 
        {
            "location": "/datatype/arr_sli_make/", 
            "text": "make：在初始化时候就指定len和cap\n\n\na\n \n:=\n \nmake\n([]\nint\n,\n \n5\n)\n  \n// len(a)=5\n\n\nb\n \n:=\n \nmake\n([]\nint\n,\n \n0\n,\n \n5\n)\n \n// len(b)=0, cap(b)=5\n\n\nb\n \n=\n \nb\n[:\ncap\n(\nb\n)]\n \n// len(b)=5, cap(b)=5\n\n\nb\n \n=\n \nb\n[\n1\n:]\n      \n// len(b)=4, cap(b)=4\n\n\n\n\n\n注意，在赋值时候，若超过len边界，则会报错，如\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nsli1\n \n:=\n \nmake\n([]\nint\n,\n \n0\n,\n \n5\n)\n\n    \nfmt\n.\nPrintln\n(\nsli1\n,\n \nlen\n(\nsli1\n),\n \ncap\n(\nsli1\n))\n\n\n    \nsli1\n[\n0\n]\n \n=\n \n3\n\n    \nfmt\n.\nPrintln\n(\nsli1\n,\n \nlen\n(\nsli1\n),\n \ncap\n(\nsli1\n))\n\n\n}\n\n\n\n\n\n报错\n\n\n[] 0 5\npanic: runtime error: index out of range\n\ngoroutine 1 [running]:\nmain.main()\n    /golang/example/slice.go:9 +0x2a3\nexit status 2\n\n\n\n\n改成如下才可以\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nsli1\n \n:=\n \nmake\n([]\nint\n,\n \n0\n,\n \n5\n)\n\n    \nfmt\n.\nPrintln\n(\nsli1\n,\n \nlen\n(\nsli1\n),\n \ncap\n(\nsli1\n))\n\n\n    \nsli1\n \n=\n \nsli1\n[:\ncap\n(\nsli1\n)]\n\n    \nsli1\n[\n0\n]\n \n=\n \n3\n\n    \nfmt\n.\nPrintln\n(\nsli1\n,\n \nlen\n(\nsli1\n),\n \ncap\n(\nsli1\n))\n\n\n}\n\n\n\n\n\n输出\n\n\n[] 0 5\n[3 0 0 0 0] 5 5", 
            "title": "3.6. make"
        }, 
        {
            "location": "/datatype/arr_sli_nest/", 
            "text": "slice可以嵌套包含slice，并且可以嵌套多层\n\n\n嵌套一层\n\n\nboard1\n \n:=\n \n[][]\nstring\n{\n\n    \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n    \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n    \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n\n}\n\n\n\n\n\n嵌套两层\n\n\nboard2\n \n:=\n \n[][][]\nstring\n{\n\n    \n[][]\nstring\n{\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n    \n},\n\n    \n[][]\nstring\n{\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n    \n},\n\n    \n[][]\nstring\n{\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n        \n[]\nstring\n{\n_\n,\n \n_\n,\n \n_\n},\n\n    \n},\n\n\n}\n\n\n\n\n\n赋值\n\n\nboard1\n[\n0\n][\n0\n]\n \n=\n \nX\n\n\nboard2\n[\n0\n][\n0\n][\n0\n]\n \n=\n \nY\n\n\n\n\n\n通过嵌套实现了高级数据结构，比如python中列表嵌套字典嵌套列表等等\n\n\n\n\n分解说明\n\n\nboard1 := [][]string\n 这里的\n[][]string\n可以分解成\n[] []string来看\n，比如\n[]int\n表示元素都是整型的slice，\n[]string\n表示元素都是字符串型的slice，那么\n[][]string\n就表示元素为\n[]string\n类型的slice\n\n\n\n\n\n\n注意逗号\n\n\n可以看到，golang的数据结构，当表示多个元素的时候，若使用了逗号，则最后一个元素后也必须加逗号，否则会报错", 
            "title": "3.7. slice嵌套"
        }, 
        {
            "location": "/datatype/arr_sli_expand/", 
            "text": "虽然slice不像array是永久不变的长度和容量，但是每次声明或赋值后容量是固定的。\n\n\nslice扩容有多种方法\n\n\n\n\n\n\nliteral赋值，但每次赋值之后，原来的元素就丢失了，详见\n关于literal\n\n\n\n\n\n\n使用append，详见\nappend添加元素", 
            "title": "3.8. slice扩容"
        }, 
        {
            "location": "/datatype/arr_sli_append/", 
            "text": "sli = append(sli, 元素)\n\n\n\n\n注意：在添加元素时候，\n若原本slice的容量不够了，则会自动扩大一倍cap\n，在扩大cap时候是将原来元素复制一份（而不是引用）\n\n\n\n\n命令解读\n\n\nsli = append(sli, 元素)意思是先读取原有元素，然后cap扩容一倍，然后在末尾插入数字0这个元素，然后把插入完的赋值给sli（赋值给新变量也是可以的），因此和原有slice脱离关系。\n\n\n\n\n示例\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \ns\n \n[]\nint\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n0\n)\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n1\n)\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n2\n)\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \na\n \n:=\n \ns\n\n    \na\n[\n0\n]\n \n=\n \n88\n\n    \nb\n \n:=\n \ns\n\n    \nb\n[\n0\n]\n \n=\n \n888\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n3\n)\n\n    \na\n[\n0\n]\n \n=\n \n77\n\n    \nb\n[\n0\n]\n \n=\n \n777\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n4\n)\n\n    \na\n[\n0\n]\n \n=\n \n66\n\n    \nb\n[\n0\n]\n \n=\n \n666\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n5\n)\n\n    \na\n[\n0\n]\n \n=\n \n55\n\n    \nb\n[\n0\n]\n \n=\n \n555\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n6\n)\n\n    \na\n[\n0\n]\n \n=\n \n44\n\n    \nb\n[\n0\n]\n \n=\n \n444\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n7\n)\n\n    \na\n[\n0\n]\n \n=\n \n33\n\n    \nb\n[\n0\n]\n \n=\n \n333\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n8\n)\n\n    \na\n[\n0\n]\n \n=\n \n22\n\n    \nb\n[\n0\n]\n \n=\n \n222\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n    \ns\n \n=\n \nappend\n(\ns\n,\n \n9\n)\n\n    \na\n[\n0\n]\n \n=\n \n11\n\n    \nb\n[\n0\n]\n \n=\n \n111\n\n    \nprintSlice\n(\ns\n,\n \ns\n)\n\n    \nprintSlice\n(\na\n,\n \na\n)\n\n    \nprintSlice\n(\nb\n,\n \nb\n)\n\n\n}\n\n\n\nfunc\n \nprintSlice\n(\nstr\n \nstring\n,\n \ns\n \n[]\nint\n)\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%s len=%d cap=%d %v\\n\n,\n \nstr\n,\n \nlen\n(\ns\n),\n \ncap\n(\ns\n),\n \ns\n)\n\n\n}\n\n\n\n\n输出\ns len=0 cap=0 []\ns len=1 cap=1 [0]\ns len=2 cap=2 [0 1]\ns len=3 cap=4 [0 1 2]\na len=3 cap=4 [888 1 2]\nb len=3 cap=4 [888 1 2]\ns len=4 cap=4 [777 1 2 3]\na len=3 cap=4 [777 1 2]\nb len=3 cap=4 [777 1 2]\ns len=5 cap=8 [777 1 2 3 4]\na len=3 cap=4 [666 1 2]\nb len=3 cap=4 [666 1 2]\ns len=6 cap=8 [777 1 2 3 4 5]\na len=3 cap=4 [555 1 2]\nb len=3 cap=4 [555 1 2]\ns len=7 cap=8 [777 1 2 3 4 5 6]\na len=3 cap=4 [444 1 2]\nb len=3 cap=4 [444 1 2]\ns len=8 cap=8 [777 1 2 3 4 5 6 7]\na len=3 cap=4 [333 1 2]\nb len=3 cap=4 [333 1 2]\ns len=9 cap=16 [777 1 2 3 4 5 6 7 8]\na len=3 cap=4 [222 1 2]\nb len=3 cap=4 [222 1 2]\ns len=10 cap=16 [777 1 2 3 4 5 6 7 8 9]\na len=3 cap=4 [111 1 2]\nb len=3 cap=4 [111 1 2]\n\n\n\n注意：虽然a是s的衍生出来的，但从上面红色部分开始，a和s就分道扬镳了", 
            "title": "3.9. append添加元素"
        }, 
        {
            "location": "/datatype/arr_sli_copy/", 
            "text": "copy使用\n\n\n\n\na\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n\nd\n \n:=\n \nmake\n([]\nint\n,\n \nlen\n(\na\n))\n\n\ncopy\n(\nd\n,\n \na\n)\n\n\n\n\n\n上面将a的元素复制给了d，是复制而不是引用\n\n\n\n\n\n\nappend和copy都是可以将元素内容拷贝给另一个slice（用于复制而不是引用），这样新生成的slice就和原来的slice彻底脱离关系了（复制元素内容到新的内存地址）\n\n\n\n\n\n\nappend当容量不够时候会扩大cap，而扩大cap是将元素内容复制出来，因此从原来slice衍生出来的slice都将和这个slice脱离关系\n\n\n\n\n\n\ncopy无法自己复制给自己，即\ncopy(a,a)\n这样虽然不报错，但是没有任何效果（没有和衍生的slice脱离关系）\n\n\n\n\n\n\ncopy里第2个参数也必须是slice，且类型要和第一个参数一致\n\n\n\n\n\n\n当复制的元素和被复制的元素个数不一致时\n\n\n\n\n\n\n\n\n不会扩大被复制的cap\n\n\n\n\n\n\n会在len范围内产生覆盖\n\n\n\n\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \n[]\nint\n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n}\n\n\n    \ns1\n \n:=\n \nmake\n([]\nint\n,\n \n5\n,\n \n10\n)\n\n    \nfmt\n.\nPrintln\n(\ns1\n)\n\n    \ncopy\n(\ns1\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\ns1\n,\n \nlen\n(\ns1\n),\n \ncap\n(\ns1\n))\n\n\n    \nfmt\n.\nPrintln\n(\n-----\n)\n\n\n    \ns2\n \n:=\n \nmake\n([]\nint\n,\n \n3\n,\n \n10\n)\n\n    \nfmt\n.\nPrintln\n(\ns2\n)\n\n    \ncopy\n(\ns2\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\ns2\n,\n \nlen\n(\ns2\n),\n \ncap\n(\ns2\n))\n\n\n    \nfmt\n.\nPrintln\n(\n-----\n)\n\n\n    \ns3\n \n:=\n \nmake\n([]\nint\n,\n \n7\n,\n \n10\n)\n\n    \nfmt\n.\nPrintln\n(\ns3\n)\n\n    \ncopy\n(\ns3\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\ns3\n,\n \nlen\n(\ns3\n),\n \ncap\n(\ns3\n))\n\n\n    \nfmt\n.\nPrintln\n(\n-----\n)\n\n\n    \ns4\n \n:=\n \nmake\n([]\nint\n,\n \n3\n,\n \n3\n)\n\n    \nfmt\n.\nPrintln\n(\ns4\n)\n\n    \ncopy\n(\ns4\n,\n \na\n)\n\n    \nfmt\n.\nPrintln\n(\ns4\n,\n \nlen\n(\ns4\n),\n \ncap\n(\ns4\n))\n\n\n}\n\n\n\n\n\n输出\n\n\n[0 0 0 0 0]\n[1 2 3 4 5] 5 10\n-----\n[0 0 0]\n[1 2 3] 3 10\n-----\n[0 0 0 0 0 0 0]\n[1 2 3 4 5 0 0] 7 10\n-----\n[0 0 0]\n[1 2 3] 3 3", 
            "title": "3.10. copy复制元素"
        }, 
        {
            "location": "/datatype/arr_sli_copy/#copy", 
            "text": "a   :=   [] int { 2 ,   3 ,   5 ,   7 ,   11 ,   13 }  d   :=   make ([] int ,   len ( a ))  copy ( d ,   a )   上面将a的元素复制给了d，是复制而不是引用    append和copy都是可以将元素内容拷贝给另一个slice（用于复制而不是引用），这样新生成的slice就和原来的slice彻底脱离关系了（复制元素内容到新的内存地址）    append当容量不够时候会扩大cap，而扩大cap是将元素内容复制出来，因此从原来slice衍生出来的slice都将和这个slice脱离关系    copy无法自己复制给自己，即 copy(a,a) 这样虽然不报错，但是没有任何效果（没有和衍生的slice脱离关系）    copy里第2个参数也必须是slice，且类型要和第一个参数一致", 
            "title": "copy使用"
        }, 
        {
            "location": "/datatype/arr_sli_copy/#_1", 
            "text": "不会扩大被复制的cap    会在len范围内产生覆盖    package   main  import   fmt  func   main ()   { \n     a   :=   [] int { 1 ,   2 ,   3 ,   4 ,   5 } \n\n     s1   :=   make ([] int ,   5 ,   10 ) \n     fmt . Println ( s1 ) \n     copy ( s1 ,   a ) \n     fmt . Println ( s1 ,   len ( s1 ),   cap ( s1 )) \n\n     fmt . Println ( ----- ) \n\n     s2   :=   make ([] int ,   3 ,   10 ) \n     fmt . Println ( s2 ) \n     copy ( s2 ,   a ) \n     fmt . Println ( s2 ,   len ( s2 ),   cap ( s2 )) \n\n     fmt . Println ( ----- ) \n\n     s3   :=   make ([] int ,   7 ,   10 ) \n     fmt . Println ( s3 ) \n     copy ( s3 ,   a ) \n     fmt . Println ( s3 ,   len ( s3 ),   cap ( s3 )) \n\n     fmt . Println ( ----- ) \n\n     s4   :=   make ([] int ,   3 ,   3 ) \n     fmt . Println ( s4 ) \n     copy ( s4 ,   a ) \n     fmt . Println ( s4 ,   len ( s4 ),   cap ( s4 ))  }   输出  [0 0 0 0 0]\n[1 2 3 4 5] 5 10\n-----\n[0 0 0]\n[1 2 3] 3 10\n-----\n[0 0 0 0 0 0 0]\n[1 2 3 4 5 0 0] 7 10\n-----\n[0 0 0]\n[1 2 3] 3 3", 
            "title": "当复制的元素和被复制的元素个数不一致时"
        }, 
        {
            "location": "/datatype/map_main/", 
            "text": "map就是键值对(key-\nvalue)，在其他语言中通常叫hash或者字典\n\n\n完整写法\n\n\n\n\nvar m map[key_type]value_type\nm = make(map[key_type]value_type)\n\n\n\n\n例子\n\n\nvar m map[string]int\nm = make(map[string]int)\n\n\n\n\n\n\n简写\n\n\nvar m map[key_type]value_type = make(map[key_type]value_type)\n\n\n\n\n例子\n\n\nvar m map[string]int = make(make[string]int)\n\n\n\n\n\n\n短声明写法\n\n\n\n\nm := make(map[key_type]value_type)\n\n\n\n\n例子\n\n\nm := make(map[string]int)", 
            "title": "4.1. 声明"
        }, 
        {
            "location": "/datatype/map_main/#_1", 
            "text": "var m map[key_type]value_type\nm = make(map[key_type]value_type)  例子  var m map[string]int\nm = make(map[string]int)   简写  var m map[key_type]value_type = make(map[key_type]value_type)  例子  var m map[string]int = make(make[string]int)", 
            "title": "完整写法"
        }, 
        {
            "location": "/datatype/map_main/#_2", 
            "text": "m := make(map[key_type]value_type)  例子  m := make(map[string]int)", 
            "title": "短声明写法"
        }, 
        {
            "location": "/datatype/map_nil/", 
            "text": "只有仅写\nvar m map[key_type]value_type\n才能得到nil map\n\n\n一旦初始化，即\nm = make(map[key_type]value_type)\n就不是nil map了\n\n\n\n\nNote\n\n\nnil map是无法通过%T看到，%T看到的都是map[key_type]value_type，比如map[string]int\n\n\n若往nil map（即未make的map）中插入键值对，则会报错\npanic: assignment to entry in nil map", 
            "title": "4.2. nil map"
        }, 
        {
            "location": "/datatype/map_struct/", 
            "text": "type\n \nKey\n \nstruct\n \n{\n\n    \na\n,\n \nb\n \nstring\n\n\n}\n\n\n\ntype\n \nValue\n \nstruct\n \n{\n\n    \nc\n,\n \nd\n \nint\n\n\n}\n\n\n\nvar\n \nm\n \nmap\n[\nKey\n]\nValue\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nm\n \n=\n \nmake\n(\nmap\n[\nKey\n]\nValue\n)\n\n    \nm\n[\nKey\n{\n\n        \nA\n,\n \nB\n,\n\n    \n}]\n \n=\n \nValue\n{\n\n        \n1\n,\n \n2\n,\n\n    \n}\n\n    \nfmt\n.\nPrintln\n(\nm\n[\nKey\n{\n\n        \nA\n,\nB\n,\n\n    \n}])\n\n    \nfmt\n.\nPrintln\n(\nm\n)\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nm\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n{1 2}\nmap[{A B}:{1 2}]\nmap[main.Key]main.Value\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nKey、Value写在函数外和写在main函数里，都是main.key、main.Value\n\n\n\n\n\n\n上面的Key、Value、m的声明都可以放到main函数里写", 
            "title": "4.3. key和value可以用struct"
        }, 
        {
            "location": "/datatype/map_literal/", 
            "text": "type\n \nVertex\n \nstruct\n \n{\n\n    \nLat\n,\n \nLong\n \nfloat64\n\n\n}\n\n\n\nvar\n \nm\n \n=\n \nmap\n[\nstring\n]\nVertex\n{\n\n    \nBell Labs\n:\n \nVertex\n{\n\n        \n40.68433\n,\n \n-\n74.39967\n,\n\n    \n},\n\n    \nGoogle\n:\n \nVertex\n{\n\n        \n37.42202\n,\n \n-\n122.08408\n,\n\n    \n},\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nm\n)\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nm\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nmap[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]\nmap[string]main.Vertex\n\n\n\n\n\n\n简写方式\n\n\n\n\nIf the top-level type is just a type name, you can omit it from the elements of the literal.\n\n\n\n\nvar\n \nm\n \n=\n \nmap\n[\nstring\n]\nVertex\n{\n\n    \nBell Labs\n:\n \nVertex\n{\n\n        \n40.68433\n,\n \n-\n74.39967\n,\n\n    \n},\n\n    \nGoogle\n:\n \nVertex\n{\n\n        \n37.42202\n,\n \n-\n122.08408\n,\n\n    \n},\n\n\n}\n\n\n\n可以简写为\n\n\nvar\n \nm\n \n=\n \nmap\n[\nstring\n]\nVertex\n{\n\n    \nBell Labs\n:\n \n{\n40.68433\n,\n \n-\n74.39967\n},\n\n    \nGoogle\n:\n    \n{\n37.42202\n,\n \n-\n122.08408\n},\n\n\n}", 
            "title": "4.4. literal"
        }, 
        {
            "location": "/datatype/map_get_insert_update/", 
            "text": "检索值\n\n\n\n\nm[key]\n\n\n\n\n比如\n\n\na := m[key]\n\n\n\n\n\n\n当检索不到时候，不会报错，而是a的值就是value类型的默认值，比如value是int类型，那a就是0\n\n\n\n\ntwo-value写法：\n\n\na, ok := m[key]\n\n\n\n\n当key存在时，ok是true，否则是false\n\n\n插入或更新值\n\n\n\n\n当key不存在时候就是插入新的key-value：\n\n\nm[key] = value", 
            "title": "4.5. 检索、添加和修改元素"
        }, 
        {
            "location": "/datatype/map_get_insert_update/#_1", 
            "text": "m[key]  比如  a := m[key]   当检索不到时候，不会报错，而是a的值就是value类型的默认值，比如value是int类型，那a就是0   two-value写法：  a, ok := m[key]  当key存在时，ok是true，否则是false", 
            "title": "检索值"
        }, 
        {
            "location": "/datatype/map_get_insert_update/#_2", 
            "text": "当key不存在时候就是插入新的key-value：  m[key] = value", 
            "title": "插入或更新值"
        }, 
        {
            "location": "/datatype/map_delete/", 
            "text": "delete(m, key)\n\n\n\n\n比如\n\n\ndelete(m, \nAnswer\n)\n\n\n\n\n\n\n当Answer不存在时候不会提示报错", 
            "title": "4.6. delete删除元素"
        }, 
        {
            "location": "/datatype/funcvalue_main/", 
            "text": "函数值(Function values): 函数也是值。他们可以像其他值一样传递，比如，函数值可以作为函数的参数或者返回值。\n\n\n在其他语言里，函数值叫做函数指针(Function pointer)，常用于回调和闭包\n\n\n举例\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nbb\n(\nx\n,\n \ny\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \nx\n \n+\n \ny\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ncc\n \n:=\n \nfunc\n(\nx\n,\n \ny\n \nint\n)\n \nint\n \n{\n\n        \nreturn\n \nx\n \n+\n \ny\n\n    \n}\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nbb\n)\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \ncc\n)\n\n    \nfmt\n.\nPrintln\n(\nbb\n(\n1\n,\n \n2\n))\n\n    \nfmt\n.\nPrintln\n(\ncc\n(\n1\n,\n \n2\n))\n\n\n}\n\n\n\n\n\n输出\n\n\nfunc(int, int) int\nfunc(int, int) int\n3\n3\n\n\n\n\n结论:\n\n\n\n\n\n\n函数bb的类型和变量cc的类型相同，都是func(int, int) int\n\n\n\n\n\n\n说明bb和cc是相同的，只是写法不同，但实质是相同的，而且使用起来效果也一样", 
            "title": "5.1. 介绍"
        }, 
        {
            "location": "/datatype/funcvalue_parameter/", 
            "text": "一个函数可以作为参数传递给另一个函数：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \ndd\n(\ni\n \nfunc\n(\nint\n,\n \nint\n)\n \nint\n)\n \nint\n \n{\n\n    \nfmt\n.\nPrintf\n(\ni type: %T\\n\n,\n \ni\n)\n\n    \nreturn\n \ni\n(\n1\n,\n \n2\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nee\n \n:=\n \nfunc\n(\nx\n,\n \ny\n \nint\n)\n \nint\n \n{\n\n        \nreturn\n \nx\n \n+\n \ny\n\n    \n}\n\n    \nfmt\n.\nPrintf\n(\nee type: %T\\n\n,\n \nee\n)\n\n    \nfmt\n.\nPrintln\n(\ndd\n(\nee\n))\n\n\n}\n\n\n\n\n\n输出\n\n\nee type: func(int, int) int\ni type: func(int, int) int\n3\n\n\n\n\n上面这个例子就是函数ee作为参数传递给函数dd\n\n\n\n\nNote\n\n\n注意：为什么dd(ee)这样是可以的，是因为ee的值的类型和dd的参数i的类型是一致的\n\n\n上面这种做法，也可以这么去理解：\n\n\n比如简单的函数：\n\n\nfunc\n \nabc\n(\ni\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \ni\n \n+\n \n1\n\n\n}\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nabc\n(\n2\n))\n\n\n}\n\n\n\n\n\n上面可以理解为2的类型为int，和abc的参数i的类型一致，所以可以abc(2)，接着就是执行abc函数，将2赋值给i，然后执行2 + 1，结果为3\n\n\n同理，在上面的上面这个例子中，ee的类型为func(int, int) int，和dd的参数i的类型一致，所以可以dd(ee)，接着就是执行dd函数，将ee赋值给i，然后执行i(1, 2)，这里有点像变量替换，即i(1, 2)可以替换成ee(1, 2)，即return ee(1, 2)，也就是return 1 + 2，结果为3。（这行描述不一定对，只是目前的理解，也可能不是把ee带进去，而是ee的函数本身直接带进去）\n\n\n\n\n包级别的也能用函数值方式来声明函数，只不过要用var：\n\n\nvar\n \nabc\n \n=\n \nfunc\n \n(\ni\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \ni\n \n+\n \n1\n\n\n}\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nabc\n(\n2\n))\n\n\n}\n\n\n\n\n\n当然也可以闲的蛋疼完整写法：\n\n\nvar\n \nabc\n \nfunc\n \n(\nint\n)\n \nint\n \n=\n \nfunc\n \n(\ni\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \ni\n \n+\n \n1\n\n\n}\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nabc\n(\n2\n))\n\n\n}", 
            "title": "5.2. 函数作为参数传递给另一个函数"
        }, 
        {
            "location": "/datatype/funcvalue_callback/", 
            "text": "什么是回调函数\n\n\n\n\n关于回调的理解，知乎上有个不错，这里贴出来: \nhttps://www.zhihu.com/question/19801131\n\n\n函数值可用于回调，下面是关于回调函数的理解:\n\n\n回调函数英文叫做callback，技术本质是就是一个通过函数指针（只不过在golang里叫函数值，不叫函数指针）调用的函数。比如将函数A作为参数传递给函数B，那么A就叫做 \n回调函数\n ，B就叫做 \n中间函数\n，调用B的函数叫做 \n起始函数\n\n\n\n\nNote\n\n\n中间函数：什么时间、做什么\n\n\n回调函数：怎么做\n\n\n\n\n回调示例（来自知乎）：\n\n\n\n\n\n\n有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于中间函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入中间函数的动作，称为登记回调函数（to register a callback function）\n\n\n\n\n\n\n你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里， 你的电话号码就叫 \n回调函数\n ，你把电话留给店员就叫 \n登记回调函数\n ，店里后来有货了叫做 \n触发了回调关联的事件\n ，店员给你打电话叫做 \n调用回调函数\n ，你到店里去取货叫做 \n响应回调事件\n  。\n\n\n\n\n\n\n\n\n回调: 回过头来调用\n\n\n回调函数这4个字容易让人理解为调用别人，这是错误的，如果在前面加上一个\"被\"字就好理解了，即等着被中间函数调用，只不过回调函数是主程序写的，也就是自己的意思，所以叫回调。\n\n\n我是这么记忆的：我把我写的函数，传递给你，希望你在某个时候 \n回过头来调用\n 我的这个函数。那么这个函数就称为回调函数\n\n\n\n\n下面是一个代码例子，可以比较下python和golang在回调方面的编码区别\n\n\n\n\n\n\npython示例\n\n\neven.py\n#!/usr/bin/env python\n\n\n# -*- coding: utf-8 -*-\n\n\n\n#回调函数1\n\n\n#生成一个2k形式的偶数\n\n\ndef\n \ndouble\n(\nx\n):\n\n    \nreturn\n \nx\n \n*\n \n2\n\n\n\n#回调函数2\n\n\n#生成一个4k形式的偶数\n\n\ndef\n \nquadruple\n(\nx\n):\n\n    \nreturn\n \nx\n \n*\n \n4\n\n\n\n\nmain.py\nfrom\n \neven\n \nimport\n \n*\n\n\n\n#中间函数\n\n\n#接受一个生成偶数的函数作为参数\n\n\n#返回一个奇数\n\n\ndef\n \ngetOddNumber\n(\nk\n,\n \ngetEvenNumber\n):\n\n    \nreturn\n \n1\n \n+\n \ngetEvenNumber\n(\nk\n)\n\n\n\n#起始函数，这里是程序的主函数\n\n\ndef\n \nmain\n():\n\n    \nk\n \n=\n \n1\n\n\n    \n#当需要生成一个2k+1形式的奇数时\n\n    \ni\n \n=\n \ngetOddNumber\n(\nk\n,\n \ndouble\n)\n\n    \nprint\n(\ni\n)\n\n\n    \n#当需要一个4k+1形式的奇数时\n\n    \ni\n \n=\n \ngetOddNumber\n(\nk\n,\n \nquadruple\n)\n\n    \nprint\n(\ni\n)\n\n\n\nif\n \n__name__\n \n==\n \n__main__\n:\n\n    \nmain\n()\n\n\n\n\n python main.py\n\n 3\n\n 5\n\n\n\n\n\n\n\n\ngolang示例\n\n\n$GOPATH/src/github.com/cyent/golang/example/even/even.go\npackage\n \neven\n\n\n\n//回调函数1\n\n\n//生成一个2k形式的偶数\n\n\nfunc\n \nDouble\n(\nx\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \nx\n \n*\n \n2\n\n\n}\n\n\n\n//回调函数2\n\n\n//生成一个4k形式的偶数\n\n\nfunc\n \nQuadruple\n(\nx\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \nx\n \n*\n \n4\n\n\n}\n\n\n\n\nmain.go\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \ngithub.com/cyent/golang/example/even\n\n\n)\n\n\n\n//中间函数\n\n\n//接受一个生成偶数的函数作为参数\n\n\n//返回一个奇数\n\n\nfunc\n \ngetOddNumber\n(\nk\n \nint\n,\n \ngetEvenNumber\n \nfunc\n(\nint\n)\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \n1\n \n+\n \ngetEvenNumber\n(\nk\n)\n\n\n}\n\n\n\n//起始函数，这里是程序的主函数\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nk\n \n:=\n \n1\n\n\n    \n//当需要生成一个2k+1形式的奇数时\n\n    \ni\n \n:=\n \ngetOddNumber\n(\nk\n,\n \neven\n.\nDouble\n)\n\n    \nfmt\n.\nPrintln\n(\ni\n)\n\n\n    \n//当需要一个4k+1形式的奇数时\n\n    \ni\n \n=\n \ngetOddNumber\n(\nk\n,\n \neven\n.\nQuadruple\n)\n\n    \nfmt\n.\nPrintln\n(\ni\n)\n\n\n}\n\n\n\n\n go run main.go\n\n 3\n\n 5\n\n\n\n\n\n\n\n\n可以看出，python是隐式函数指针，而golang是显式函数指针（函数值）\n\n\n我的例子\n\n\n\n\n使用libvirt api对虚拟机进行操作，有2种方式：\n\n\n\n\n\n\n只写一个libvirt模块，接收参数来对虚拟机进行启动、停止、重启、删除等操作。但这样有3个问题\n\n\n\n\n这个模块要做很多类型的事情，包括连接libvirt接口、宿主机操作（网络、存储、性能获取）、vm操作（创建、删除、启动、停止）\n\n\n这个模块要维护libvirt版本的兼容性，当版本越来越多的时候，会因为兼容各个版本导致模块很臃肿\n\n\n每增加一个对虚拟机操作的功能，都是在更新这个模块，次数多了，自然也变得臃肿\n\n\n\n\n\n\n\n\nlibvirt模块只写最基础的功能，例如只写连接libvirt接口，然后接收一个函数来对宿主机或者虚拟机做操作。然后调用者自己实现宿主机操作的回调函数、虚拟机操作的回调函数，例如需要对某个虚拟机进行启动，操作是：\n\n\n\n\n调用libvirt模块连接api\n\n\n传入调用者自己实现的启动虚拟机的回调函数作为参数传递给libvirt模块\n\n\n\n\n这样的好处有2个：\n\n\n\n\n将原本libvirt模块需要做的3件事，拆解开来，维护量大大减少\n\n\n调用者需要哪个功能，就实现哪个功能，不需要就不用实现，代码开量明显减少\n\n\n\n\n例如：\n\n\n上面提到的调用者，可以叫vm.py，libvirt模块分为kvm.py、container.py，用到kvm.py时候就import kvm\n\n\nvm.py\n\nimport\n \nkvm\n\n\n\ndef\n \nreboot\n(\ndom_uuid\n,\n \nhost_ip\n):\n\n    \ndef\n \nshutdown_vm\n(\ndom\n):\n\n        \n...\n\n    \nkvm\n.\nlibvirt_connect\n(\nshutdown_vm\n(\ndom\n),\n \nhost_ip\n,\n \ndom_uuid\n=\ndom_uuid\n)\n\n\n\n\nkvm.py\n\n# 封装libvirt connect\n\n\ndef\n \nlibvirt_conenct\n(\ncallback\n,\n \nhost\n,\n \ndom_uuid\n=\nNone\n):\n\n    \ncallback\n(\n...\n)\n\n\n\n\n\n\n这个例子也是阻塞式回调，延迟式回调还没研究过~\n\n\n\n\n\n\n\n\n回调函数类型\n\n\n\n\n有两种类型的回调函数：\n\n\n\n\n\n\n阻塞式回调（也叫同步回调）\n\n\n\n\nblocking callbacks (also known as synchronous callbacks or just callbacks)\n\n\n\n\n\n\n\n\n延迟式回调（也叫异步回调）\n\n\n\n\ndeferred callbacks (also known as asynchronous callbacks)\n\n\n\n\n\n\n\n\n本页所有例子都是阻塞式回调", 
            "title": "5.3. 用途1-回调函数"
        }, 
        {
            "location": "/datatype/funcvalue_callback/#_1", 
            "text": "关于回调的理解，知乎上有个不错，这里贴出来:  https://www.zhihu.com/question/19801131  函数值可用于回调，下面是关于回调函数的理解:  回调函数英文叫做callback，技术本质是就是一个通过函数指针（只不过在golang里叫函数值，不叫函数指针）调用的函数。比如将函数A作为参数传递给函数B，那么A就叫做  回调函数  ，B就叫做  中间函数 ，调用B的函数叫做  起始函数   Note  中间函数：什么时间、做什么  回调函数：怎么做   回调示例（来自知乎）：    有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于中间函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入中间函数的动作，称为登记回调函数（to register a callback function）    你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里， 你的电话号码就叫  回调函数  ，你把电话留给店员就叫  登记回调函数  ，店里后来有货了叫做  触发了回调关联的事件  ，店员给你打电话叫做  调用回调函数  ，你到店里去取货叫做  响应回调事件   。     回调: 回过头来调用  回调函数这4个字容易让人理解为调用别人，这是错误的，如果在前面加上一个\"被\"字就好理解了，即等着被中间函数调用，只不过回调函数是主程序写的，也就是自己的意思，所以叫回调。  我是这么记忆的：我把我写的函数，传递给你，希望你在某个时候  回过头来调用  我的这个函数。那么这个函数就称为回调函数   下面是一个代码例子，可以比较下python和golang在回调方面的编码区别    python示例  even.py #!/usr/bin/env python  # -*- coding: utf-8 -*-  #回调函数1  #生成一个2k形式的偶数  def   double ( x ): \n     return   x   *   2  #回调函数2  #生成一个4k形式的偶数  def   quadruple ( x ): \n     return   x   *   4   main.py from   even   import   *  #中间函数  #接受一个生成偶数的函数作为参数  #返回一个奇数  def   getOddNumber ( k ,   getEvenNumber ): \n     return   1   +   getEvenNumber ( k )  #起始函数，这里是程序的主函数  def   main (): \n     k   =   1 \n\n     #当需要生成一个2k+1形式的奇数时 \n     i   =   getOddNumber ( k ,   double ) \n     print ( i ) \n\n     #当需要一个4k+1形式的奇数时 \n     i   =   getOddNumber ( k ,   quadruple ) \n     print ( i )  if   __name__   ==   __main__ : \n     main ()    python main.py  3  5    golang示例  $GOPATH/src/github.com/cyent/golang/example/even/even.go package   even  //回调函数1  //生成一个2k形式的偶数  func   Double ( x   int )   int   { \n     return   x   *   2  }  //回调函数2  //生成一个4k形式的偶数  func   Quadruple ( x   int )   int   { \n     return   x   *   4  }   main.go package   main  import   ( \n     fmt \n     github.com/cyent/golang/example/even  )  //中间函数  //接受一个生成偶数的函数作为参数  //返回一个奇数  func   getOddNumber ( k   int ,   getEvenNumber   func ( int )   int )   int   { \n     return   1   +   getEvenNumber ( k )  }  //起始函数，这里是程序的主函数  func   main ()   { \n     k   :=   1 \n\n     //当需要生成一个2k+1形式的奇数时 \n     i   :=   getOddNumber ( k ,   even . Double ) \n     fmt . Println ( i ) \n\n     //当需要一个4k+1形式的奇数时 \n     i   =   getOddNumber ( k ,   even . Quadruple ) \n     fmt . Println ( i )  }    go run main.go  3  5    可以看出，python是隐式函数指针，而golang是显式函数指针（函数值）", 
            "title": "什么是回调函数"
        }, 
        {
            "location": "/datatype/funcvalue_callback/#_2", 
            "text": "使用libvirt api对虚拟机进行操作，有2种方式：    只写一个libvirt模块，接收参数来对虚拟机进行启动、停止、重启、删除等操作。但这样有3个问题   这个模块要做很多类型的事情，包括连接libvirt接口、宿主机操作（网络、存储、性能获取）、vm操作（创建、删除、启动、停止）  这个模块要维护libvirt版本的兼容性，当版本越来越多的时候，会因为兼容各个版本导致模块很臃肿  每增加一个对虚拟机操作的功能，都是在更新这个模块，次数多了，自然也变得臃肿     libvirt模块只写最基础的功能，例如只写连接libvirt接口，然后接收一个函数来对宿主机或者虚拟机做操作。然后调用者自己实现宿主机操作的回调函数、虚拟机操作的回调函数，例如需要对某个虚拟机进行启动，操作是：   调用libvirt模块连接api  传入调用者自己实现的启动虚拟机的回调函数作为参数传递给libvirt模块   这样的好处有2个：   将原本libvirt模块需要做的3件事，拆解开来，维护量大大减少  调用者需要哪个功能，就实现哪个功能，不需要就不用实现，代码开量明显减少   例如：  上面提到的调用者，可以叫vm.py，libvirt模块分为kvm.py、container.py，用到kvm.py时候就import kvm  vm.py import   kvm  def   reboot ( dom_uuid ,   host_ip ): \n     def   shutdown_vm ( dom ): \n         ... \n     kvm . libvirt_connect ( shutdown_vm ( dom ),   host_ip ,   dom_uuid = dom_uuid )   kvm.py # 封装libvirt connect  def   libvirt_conenct ( callback ,   host ,   dom_uuid = None ): \n     callback ( ... )    这个例子也是阻塞式回调，延迟式回调还没研究过~", 
            "title": "我的例子"
        }, 
        {
            "location": "/datatype/funcvalue_callback/#_3", 
            "text": "有两种类型的回调函数：    阻塞式回调（也叫同步回调）   blocking callbacks (also known as synchronous callbacks or just callbacks)     延迟式回调（也叫异步回调）   deferred callbacks (also known as asynchronous callbacks)     本页所有例子都是阻塞式回调", 
            "title": "回调函数类型"
        }, 
        {
            "location": "/datatype/funcvalue_closure/", 
            "text": "作用：缩小变量作用域，减少对全局变量的污染\n\n\n先上例子\n\n\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nadder\n()\n \nfunc\n(\nint\n)\n \nint\n \n{\n\n    \nsum\n \n:=\n \n0\n\n    \nreturn\n \nfunc\n(\nx\n \nint\n)\n \nint\n \n{\n\n        \nsum\n \n+=\n \nx\n\n        \nreturn\n \nsum\n\n    \n}\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \npos\n,\n \nneg\n \n:=\n \nadder\n(),\n \nadder\n()\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n \n{\n\n        \nfmt\n.\nPrintln\n(\n\n            \npos\n(\ni\n),\n\n            \nneg\n(\n-\n2\n*\ni\n),\n\n        \n)\n\n    \n}\n\n\n}\n\n\n\n\n\n输出\n\n\n0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90\n\n\n\n\n\n\nNote\n\n\npos, neg := adder(), adder()\n\n\n\n\n相当于\n\n\npos := adder()\nneg := adder()\n\n\n\n\nvar可以这么写\n\n\nvar pos func(int) int\nvar neg func(int) int\npos = adder()\nreg = adder()\n\n\n\n\n\n\n上面的\n\n\npos := adder()\n\n\n\n\n可以理解为：执行adder()，然后将其return的内容赋值给pos，而return的内容就是一个标准的函数，即：\n\n\nfunc\n(\nx\n \nint\n)\n \nint\n \n{\n\n    \nsum\n \n+=\n \nx\n\n    \nreturn\n \nsum\n\n\n}\n\n\n\n\n\n\n\n因此，这个时候就是\n\n\npos\n \n:=\n \nfunc\n(\nx\n \nint\n)\n \nint\n \n{\n\n    \nsum\n \n+=\n \nx\n\n    \nreturn\n \nsum\n\n\n}\n\n\n\n\n\n等同于\n\n\nfunc\n \npos\n(\nx\n \nint\n)\n \nint\n \n{\n\n    \nsum\n \n+=\n \nx\n\n    \nreturn\n \nsum\n\n\n}\n\n\n\n\n\n\n\n闭包函数本身可用函数值书写\n\n\n\n\n比如上面这个例子，也可以写成：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nadder\n \n:=\n \nfunc\n \n()\n \nfunc\n(\nint\n)\n \nint\n \n{\n\n        \nsum\n \n:=\n \n0\n\n        \nreturn\n \nfunc\n(\nx\n \nint\n)\n \nint\n \n{\n\n            \nsum\n \n+=\n \nx\n\n            \nreturn\n \nsum\n\n        \n}\n\n    \n}\n\n\n    \npos\n,\n \nneg\n \n:=\n \nadder\n(),\n \nadder\n()\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n \n{\n\n        \nfmt\n.\nPrintln\n(\n\n            \npos\n(\ni\n),\n\n            \nneg\n(\n-\n2\n*\ni\n),\n\n        \n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\n函数值内嵌函数值\n\n\n\n\n输出也是\n\n\n0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90\n\n\n\n\n什么是闭包\n\n\n\n\n\n\n官方解释（译文）\n\n\nGo 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。\n\n\n\n\n例如，函数 adder 返回一个闭包。每个返回的闭包都被绑定到其各自的 sum 变量上。\n\n\n在上面例子中（这里重新贴下代码，和上面代码一样）：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nadder\n()\n \nfunc\n(\nint\n)\n \nint\n \n{\n\n    \nsum\n \n:=\n \n0\n\n\n    \nreturn\n \nfunc\n(\nx\n \nint\n)\n \nint\n \n{\n\n\n        \nsum\n \n+=\n \nx\n\n\n        \nreturn\n \nsum\n\n\n    \n}\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \npos\n,\n \nneg\n \n:=\n \nadder\n(),\n \nadder\n()\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n \n{\n\n        \nfmt\n.\nPrintln\n(\n\n            \npos\n(\ni\n),\n\n            \nneg\n(\n-\n2\n*\ni\n),\n\n        \n)\n\n    \n}\n\n\n}\n\n\n\n\n\n上面背景高亮部分就是一个闭包，如pos := adder()的adder()表示返回了一个闭包，并赋值给了pos，同时，这个被赋值给了pos的闭包函数被绑定在sum变量上，因此pos闭包函数里的变量sum和neg变量里的sum毫无关系。\n\n\n\n\nNote\n\n\nfunc adder() func(int) int\n的\nfunc(int) int\n表示adder()的输出值的类型是func(int) int这样一个函数\n\n\n\n\n我对闭包的理解\n\n\n\n\n没有闭包的时候，函数就是一次性买卖，函数执行完毕后就无法再更改函数中变量的值（应该是内存释放了）；有了闭包后函数就成为了一个变量的值，只要变量没被释放，函数就会一直处于存活并独享的状态，因此可以后期更改函数中变量的值（因为这样就不会被go给回收内存了，会一直缓存在那里）。\n\n\n比如，实现一个计算功能：一个数从0开始，每次加上自己的值和当前循环次数（当前第几次，循环从0开始，到9，共10次），然后*2，这样迭代10次：\n\n\n没有闭包的时候这么写：\n\n\nfunc\n \nabc\n(\nx\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \nx\n \n*\n \n2\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \nint\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n \n++\n \n{\n\n        \na\n \n=\n \nabc\n(\na\n+\ni\n)\n\n        \nfmt\n.\nPrintln\n(\na\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n如果用闭包可以这么写：\n\n\nfunc\n \nabc\n()\n \nfunc\n(\nint\n)\n \nint\n \n{\n\n    \nres\n \n:=\n \n0\n\n    \nreturn\n \nfunc\n(\nx\n \nint\n)\n \nint\n \n{\n\n        \nres\n \n=\n \n(\nres\n \n+\n \nx\n)\n \n*\n \n2\n\n        \nreturn\n \nres\n\n    \n}\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nabc\n()\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n \n{\n\n        \nfmt\n.\nPrintln\n(\na\n(\ni\n))\n\n    \n}\n\n\n}\n\n\n\n\n\n2种写法输出值都是：\n\n\n0\n2\n8\n22\n52\n114\n240\n494\n1004\n2026\n\n\n\n\n从上面例子可以看出闭包的3个好处：\n\n\n\n\n\n\n不是一次性消费，被引用声明后可以重复调用，同时变量又只限定在函数里，同时每次调用不是从初始值开始（函数里长期存储变量）\n\n\n\n\n这有点像使用面向对象的感觉，实例化一个类，这样这个类里的所有方法、属性都是为某个人私有独享的。但比面向对象更加的轻量化\n\n\n\n\n\n\n\n\n用了闭包后，主函数就变得简单了，把算法封装在一个函数里，使得主函数省略了a=abc(a+i)这种麻烦事了\n\n\n\n\n\n\n变量污染少，因为如果没用闭包，就会为了传递值到函数里，而在函数外部声明变量，但这样声明的变量又会被下面的其他函数或代码误改。\n\n\n\n\n\n\n关于闭包的第一个好处，再啰嗦举个例子\n\n\n\n\n\n\n若不用闭包，则容易对函数外的变量误操作（误操作别人），例：\n\n\nvar\n \nA\n \nint\n \n=\n \n1\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nA\n \n:=\n \n2\n\n        \nfmt\n.\nPrintln\n(\nA\n)\n\n    \n}\n\n    \nfoo\n()\n\n    \nfmt\n.\nPrintln\n(\nA\n)\n\n\n}\n\n\n\n\n\n输出：\n\n\n2\n1\n\n\n\n\n如果手误将A := 2写成了A = 2，那么输出就是：\n\n\n2\n2\n\n\n\n\n即会影响外部变量A\n\n\n\n\n\n\n为了将某一个私有的值传递到某个函数里，就需要在函数外声明这个值，但是这样声明会导致这个值在其他函数里也可见了（别人误操作我），例：\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nA\n \n:=\n \n1\n\n    \nfoo\n \n:=\n \nfunc\n \n()\n \nint\n \n{\n\n        \nreturn\n \nA\n \n+\n \n1\n\n    \n}\n\n    \nB\n \n:=\n \n1\n\n    \nbar\n \n:=\n \nfunc\n \n()\n \nint\n \n{\n\n        \nreturn\n \nB\n \n+\n \n2\n\n    \n}\n\n    \nfmt\n.\nPrintln\n(\nfoo\n())\n\n    \nfmt\n.\nPrintln\n(\nbar\n())\n\n\n}\n\n\n\n\n\n输出：\n\n\n2\n3\n\n\n\n\n在bar里是可以对变量A做操作的，一个不小心就容易误修改变量A\n\n\n结论：函数外的变量只能通过参数传递进去，不要通过全局变量的方式的渠道传递进去，当函数内能读取到的变量越多，出错概率(误操作)也就越高。\n\n\n\n\n\n\n最后举个例子\n\n\n\n\n实现斐波那契数列：\n\n\n用闭包：\n\n\nfunc\n \nfibonacci\n()\n \nfunc\n()\n \nint\n \n{\n\n    \nb1\n \n:=\n \n1\n\n    \nb2\n \n:=\n \n0\n\n    \nbc\n \n:=\n \n0\n\n    \nreturn\n \nfunc\n()\n \nint\n \n{\n\n        \nbc\n \n=\n \nb1\n \n+\n \nb2\n\n        \nb1\n \n=\n \nb2\n\n        \nb2\n \n=\n \nbc\n\n        \nreturn\n \nbc\n\n    \n}\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nf\n \n:=\n \nfibonacci\n()\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n++\n \n{\n\n        \nfmt\n.\nPrintln\n(\nf\n())\n\n    \n}\n\n\n}\n\n\n\n\n\n输出\n\n\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n\n\n\n\n不用闭包：\n\n\nfunc\n \nfibonacci\n(\nnum\n \nint\n)\n \n{\n\n    \nb1\n \n:=\n \n1\n\n    \nb2\n \n:=\n \n0\n\n    \nbc\n \n:=\n \n0\n\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \nnum\n;\n \ni\n \n++\n \n{\n\n        \nbc\n \n=\n \nb1\n \n+\n \nb2\n\n        \nb1\n \n=\n \nb2\n\n        \nb2\n \n=\n \nbc\n\n        \nfmt\n.\nPrintln\n(\nbc\n)\n\n    \n}\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nfibonacci\n(\n10\n)\n\n\n}\n\n\n\n\n\n这样输出也是正确的，但是这么写的话就将循环次数交给了fibonacci函数，即这个函数是个一次性使用的，当函数执行完毕后如果再执行函数，又是从初始值（这里是b1=1）开始，如果想能继续下去，就必须在函数外声明变量，但这样又造成了变量的泛滥（即对其他代码来说这几个变量是毫无意义，还可能造成对这几个变量的误操作），而有的时候想把for循环交由main控制，而是让fibonacci函数完成核心算法、核心数据存储，同时变量又不泛滥给其他代码\n\n\n不用闭包也可以这么写：\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nb1\n \n:=\n \n1\n\n    \nb2\n \n:=\n \n0\n\n    \nbc\n \n:=\n \n0\n\n    \nfibonacci\n \n:=\n \nfunc\n \n()\n \n{\n\n        \nbc\n \n=\n \nb1\n \n+\n \nb2\n\n        \nb1\n \n=\n \nb2\n\n        \nb2\n \n=\n \nbc\n\n        \nfmt\n.\nPrintln\n(\nbc\n)\n\n    \n}\n\n    \nfor\n \ni\n \n:=\n \n0\n;\n \ni\n \n \n10\n;\n \ni\n \n++\n \n{\n\n        \nfibonacci\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n这样输出结果也是相同的，但是这么写的话，b1、b2、bc就变成了全局都能引用的变量了，而这3个变量其实只在fibonacci里用的到，所以这样把b1、b2、bc给放到全局就显得毫无意义，还有可能对这3个变量误操作", 
            "title": "5.4. 用途2-闭包"
        }, 
        {
            "location": "/datatype/funcvalue_closure/#_1", 
            "text": "package   main  import   fmt  func   adder ()   func ( int )   int   { \n     sum   :=   0 \n     return   func ( x   int )   int   { \n         sum   +=   x \n         return   sum \n     }  }  func   main ()   { \n     pos ,   neg   :=   adder (),   adder () \n     for   i   :=   0 ;   i     10 ;   i ++   { \n         fmt . Println ( \n             pos ( i ), \n             neg ( - 2 * i ), \n         ) \n     }  }   输出  0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90   Note  pos, neg := adder(), adder()  相当于  pos := adder()\nneg := adder()  var可以这么写  var pos func(int) int\nvar neg func(int) int\npos = adder()\nreg = adder()   上面的  pos := adder()  可以理解为：执行adder()，然后将其return的内容赋值给pos，而return的内容就是一个标准的函数，即：  func ( x   int )   int   { \n     sum   +=   x \n     return   sum  }    因此，这个时候就是  pos   :=   func ( x   int )   int   { \n     sum   +=   x \n     return   sum  }   等同于  func   pos ( x   int )   int   { \n     sum   +=   x \n     return   sum  }", 
            "title": "先上例子"
        }, 
        {
            "location": "/datatype/funcvalue_closure/#_2", 
            "text": "比如上面这个例子，也可以写成：  package   main  import   fmt  func   main ()   { \n     adder   :=   func   ()   func ( int )   int   { \n         sum   :=   0 \n         return   func ( x   int )   int   { \n             sum   +=   x \n             return   sum \n         } \n     } \n\n     pos ,   neg   :=   adder (),   adder () \n     for   i   :=   0 ;   i     10 ;   i ++   { \n         fmt . Println ( \n             pos ( i ), \n             neg ( - 2 * i ), \n         ) \n     }  }    Note  函数值内嵌函数值   输出也是  0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90", 
            "title": "闭包函数本身可用函数值书写"
        }, 
        {
            "location": "/datatype/funcvalue_closure/#_3", 
            "text": "官方解释（译文）  Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。   例如，函数 adder 返回一个闭包。每个返回的闭包都被绑定到其各自的 sum 变量上。  在上面例子中（这里重新贴下代码，和上面代码一样）：  package   main  import   fmt  func   adder ()   func ( int )   int   { \n     sum   :=   0       return   func ( x   int )   int   {           sum   +=   x           return   sum       }  }  func   main ()   { \n     pos ,   neg   :=   adder (),   adder () \n     for   i   :=   0 ;   i     10 ;   i ++   { \n         fmt . Println ( \n             pos ( i ), \n             neg ( - 2 * i ), \n         ) \n     }  }   上面背景高亮部分就是一个闭包，如pos := adder()的adder()表示返回了一个闭包，并赋值给了pos，同时，这个被赋值给了pos的闭包函数被绑定在sum变量上，因此pos闭包函数里的变量sum和neg变量里的sum毫无关系。   Note  func adder() func(int) int 的 func(int) int 表示adder()的输出值的类型是func(int) int这样一个函数", 
            "title": "什么是闭包"
        }, 
        {
            "location": "/datatype/funcvalue_closure/#_4", 
            "text": "没有闭包的时候，函数就是一次性买卖，函数执行完毕后就无法再更改函数中变量的值（应该是内存释放了）；有了闭包后函数就成为了一个变量的值，只要变量没被释放，函数就会一直处于存活并独享的状态，因此可以后期更改函数中变量的值（因为这样就不会被go给回收内存了，会一直缓存在那里）。  比如，实现一个计算功能：一个数从0开始，每次加上自己的值和当前循环次数（当前第几次，循环从0开始，到9，共10次），然后*2，这样迭代10次：  没有闭包的时候这么写：  func   abc ( x   int )   int   { \n     return   x   *   2  }  func   main ()   { \n     var   a   int \n     for   i   :=   0 ;   i     10 ;   i   ++   { \n         a   =   abc ( a + i ) \n         fmt . Println ( a ) \n     }  }   如果用闭包可以这么写：  func   abc ()   func ( int )   int   { \n     res   :=   0 \n     return   func ( x   int )   int   { \n         res   =   ( res   +   x )   *   2 \n         return   res \n     }  }  func   main ()   { \n     a   :=   abc () \n     for   i   :=   0 ;   i     10 ;   i ++   { \n         fmt . Println ( a ( i )) \n     }  }   2种写法输出值都是：  0\n2\n8\n22\n52\n114\n240\n494\n1004\n2026  从上面例子可以看出闭包的3个好处：    不是一次性消费，被引用声明后可以重复调用，同时变量又只限定在函数里，同时每次调用不是从初始值开始（函数里长期存储变量）   这有点像使用面向对象的感觉，实例化一个类，这样这个类里的所有方法、属性都是为某个人私有独享的。但比面向对象更加的轻量化     用了闭包后，主函数就变得简单了，把算法封装在一个函数里，使得主函数省略了a=abc(a+i)这种麻烦事了    变量污染少，因为如果没用闭包，就会为了传递值到函数里，而在函数外部声明变量，但这样声明的变量又会被下面的其他函数或代码误改。    关于闭包的第一个好处，再啰嗦举个例子    若不用闭包，则容易对函数外的变量误操作（误操作别人），例：  var   A   int   =   1  func   main ()   { \n     foo   :=   func   ()   { \n         A   :=   2 \n         fmt . Println ( A ) \n     } \n     foo () \n     fmt . Println ( A )  }   输出：  2\n1  如果手误将A := 2写成了A = 2，那么输出就是：  2\n2  即会影响外部变量A    为了将某一个私有的值传递到某个函数里，就需要在函数外声明这个值，但是这样声明会导致这个值在其他函数里也可见了（别人误操作我），例：  func   main ()   { \n     A   :=   1 \n     foo   :=   func   ()   int   { \n         return   A   +   1 \n     } \n     B   :=   1 \n     bar   :=   func   ()   int   { \n         return   B   +   2 \n     } \n     fmt . Println ( foo ()) \n     fmt . Println ( bar ())  }   输出：  2\n3  在bar里是可以对变量A做操作的，一个不小心就容易误修改变量A  结论：函数外的变量只能通过参数传递进去，不要通过全局变量的方式的渠道传递进去，当函数内能读取到的变量越多，出错概率(误操作)也就越高。", 
            "title": "我对闭包的理解"
        }, 
        {
            "location": "/datatype/funcvalue_closure/#_5", 
            "text": "实现斐波那契数列：  用闭包：  func   fibonacci ()   func ()   int   { \n     b1   :=   1 \n     b2   :=   0 \n     bc   :=   0 \n     return   func ()   int   { \n         bc   =   b1   +   b2 \n         b1   =   b2 \n         b2   =   bc \n         return   bc \n     }  }  func   main ()   { \n     f   :=   fibonacci () \n     for   i   :=   0 ;   i     10 ;   i ++   { \n         fmt . Println ( f ()) \n     }  }   输出  1\n1\n2\n3\n5\n8\n13\n21\n34\n55  不用闭包：  func   fibonacci ( num   int )   { \n     b1   :=   1 \n     b2   :=   0 \n     bc   :=   0 \n\n     for   i   :=   0 ;   i     num ;   i   ++   { \n         bc   =   b1   +   b2 \n         b1   =   b2 \n         b2   =   bc \n         fmt . Println ( bc ) \n     }  }  func   main ()   { \n     fibonacci ( 10 )  }   这样输出也是正确的，但是这么写的话就将循环次数交给了fibonacci函数，即这个函数是个一次性使用的，当函数执行完毕后如果再执行函数，又是从初始值（这里是b1=1）开始，如果想能继续下去，就必须在函数外声明变量，但这样又造成了变量的泛滥（即对其他代码来说这几个变量是毫无意义，还可能造成对这几个变量的误操作），而有的时候想把for循环交由main控制，而是让fibonacci函数完成核心算法、核心数据存储，同时变量又不泛滥给其他代码  不用闭包也可以这么写：  func   main ()   { \n     b1   :=   1 \n     b2   :=   0 \n     bc   :=   0 \n     fibonacci   :=   func   ()   { \n         bc   =   b1   +   b2 \n         b1   =   b2 \n         b2   =   bc \n         fmt . Println ( bc ) \n     } \n     for   i   :=   0 ;   i     10 ;   i   ++   { \n         fibonacci () \n     }  }   这样输出结果也是相同的，但是这么写的话，b1、b2、bc就变成了全局都能引用的变量了，而这3个变量其实只在fibonacci里用的到，所以这样把b1、b2、bc给放到全局就显得毫无意义，还有可能对这3个变量误操作", 
            "title": "最后举个例子"
        }, 
        {
            "location": "/method/overview/", 
            "text": "go没有类，但是在type上定义method，这样效果和类用起来很相似\n\n\n如果说类是对数据和方法的抽象和封装，那么接口就是对类的抽象。\n\n\nGolang 中没有 class 的概念，而是通过 interface 类型转换支持在动态类型语言中常见的鸭子类型从而达到运行时多态的效果。\n\n\n关于面向对象、泛型、鸭子类型等概念详见\n面向对象\n\n\n网上搜到的interface资料\n\n\n\n\n\n\n\n\ngo中怎样形象的理解接口\n\nhttps://segmentfault.com/q/1010000005140317\n\n\n\n\n\n\n深入理解Go Interface：\nhttp://legendtkl.com/2017/06/12/understanding-golang-interface/\n\n\n\n\n\n\n关于interface的理解: \nhttp://www.itnose.net/detail/6079953.html\n\n\n\n\n\n\n比较python和go的面向对象写法\n\n\n\n\n无基类（无接口）\n\n\npython\n\n\n#!/usr/bin/env python\n\n\n# -*- coding: utf-8 -*-\n\n\n\nclass\n \nPerson\n:\n\n    \ndef\n \n__init__\n(\nself\n,\n \nname\n):\n\n        \nself\n.\nname\n \n=\n \nname\n\n\n    \ndef\n \nprintName\n(\nself\n):\n\n        \nprint\n \nself\n.\nname\n\n\n\nme\n \n=\n \nPerson\n(\ncyent\n)\n\n\nme\n.\nprintName\n()\n\n\n\n\n\ngo\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nPerson\n \nstruct\n \n{\n\n    \nname\n \nstring\n\n\n}\n\n\n\nfunc\n \n(\np\n \n*\nPerson\n)\n \nprintName\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\np\n.\nname\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nme\n \n:=\n \nPerson\n{\nname\n:\n \ncyent\n}\n\n    \nme\n.\nprintName\n()\n\n\n}\n\n\n\n\n\n输出都是\n\n\ncyent\n\n\n\n\n有基类（使用接口）\n\n\npython\n\n\n#!/usr/bin/env python\n\n\n# -*- coding: utf-8 -*-\n\n\n\nclass\n \nSchoolMember\n:\n\n    \ndef\n \n__init__\n(\nself\n,\n \nname\n,\n \nage\n):\n\n        \nself\n.\nname\n \n=\n \nname\n\n        \nself\n.\nage\n \n=\n \nage\n\n\n    \ndef\n \ntell\n(\nself\n):\n\n        \npass\n\n\n\nclass\n \nTeacher\n(\nSchoolMember\n):\n\n    \ndef\n \n__init__\n(\nself\n,\n \nname\n,\n \nage\n,\n \nsalary\n):\n\n        \nSchoolMember\n.\n__init__\n(\nself\n,\n \nname\n,\n \nage\n)\n\n        \nself\n.\nsalary\n \n=\n \nsalary\n\n\n    \ndef\n \ntell\n(\nself\n):\n\n        \nSchoolMember\n.\ntell\n(\nself\n)\n\n        \nprint\n \nSalary: \n%d\n \n%\n \nself\n.\nsalary\n\n\n\nclass\n \nStudent\n(\nSchoolMember\n):\n\n    \ndef\n \n__init__\n(\nself\n,\n \nname\n,\n \nage\n,\n \nmarks\n):\n\n        \nSchoolMember\n.\n__init__\n(\nself\n,\n \nname\n,\n \nage\n)\n\n        \nself\n.\nmarks\n \n=\n \nmarks\n\n\n    \ndef\n \ntell\n(\nself\n):\n\n        \nSchoolMember\n.\ntell\n(\nself\n)\n\n        \nprint\n \nMarks: \n%d\n \n%\n \nself\n.\nmarks\n\n\n\nt\n \n=\n \nTeacher\n(\nMrs. Shrividya\n,\n \n40\n,\n \n30000\n)\n\n\ns\n \n=\n \nStudent\n(\nSwaroop\n,\n \n22\n,\n \n75\n)\n\n\n\nt\n.\ntell\n()\n\n\ns\n.\ntell\n()\n\n\n\n\n\n输出\n\n\nSalary: \n30000\n\nMarks: \n75\n\n\n\n\n\ngo\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nSchoolMember\n \ninterface\n \n{\n\n    \ntell\n()\n\n\n}\n\n\n\ntype\n \nTeacher\n \nstruct\n \n{\n\n    \nname\n \nstring\n\n    \nage\n \nint\n\n    \nsalary\n \nint\n\n\n}\n\n\n\ntype\n \nStudent\n \nstruct\n \n{\n\n    \nname\n \nstring\n\n    \nage\n \nint\n\n    \nmarks\n \nint\n\n\n}\n\n\n\nfunc\n \n(\nthis\n \n*\nTeacher\n)\n \ntell\n()\n \n{\n\n    \nfmt\n.\nPrintf\n(\nSalary: %d\\n\n,\n \nthis\n.\nsalary\n)\n\n\n}\n\n\n\nfunc\n \n(\nthis\n \n*\nStudent\n)\n \ntell\n()\n \n{\n\n    \nfmt\n.\nPrintf\n(\nMarks: %d\\n\n,\n \nthis\n.\nmarks\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \nt\n \nSchoolMember\n \n=\n \nTeacher\n{\nMrs. Shrividya\n,\n \n40\n,\n \n30000\n}\n\n    \nvar\n \ns\n \nSchoolMember\n \n=\n \nStudent\n{\nSwaroop\n,\n \n22\n,\n \n75\n}\n\n    \nt\n.\ntell\n()\n\n    \ns\n.\ntell\n()\n\n\n}\n\n\n\n\n\n输出\n\n\nSalary: 30000\nMarks: 75", 
            "title": "1. 概念汇总"
        }, 
        {
            "location": "/method/overview/#interface", 
            "text": "go中怎样形象的理解接口 https://segmentfault.com/q/1010000005140317    深入理解Go Interface： http://legendtkl.com/2017/06/12/understanding-golang-interface/    关于interface的理解:  http://www.itnose.net/detail/6079953.html", 
            "title": "网上搜到的interface资料"
        }, 
        {
            "location": "/method/overview/#pythongo", 
            "text": "", 
            "title": "比较python和go的面向对象写法"
        }, 
        {
            "location": "/method/overview/#_1", 
            "text": "python  #!/usr/bin/env python  # -*- coding: utf-8 -*-  class   Person : \n     def   __init__ ( self ,   name ): \n         self . name   =   name \n\n     def   printName ( self ): \n         print   self . name  me   =   Person ( cyent )  me . printName ()   go  package   main  import   fmt  type   Person   struct   { \n     name   string  }  func   ( p   * Person )   printName ()   { \n     fmt . Println ( p . name )  }  func   main ()   { \n     me   :=   Person { name :   cyent } \n     me . printName ()  }   输出都是  cyent", 
            "title": "无基类（无接口）"
        }, 
        {
            "location": "/method/overview/#_2", 
            "text": "python  #!/usr/bin/env python  # -*- coding: utf-8 -*-  class   SchoolMember : \n     def   __init__ ( self ,   name ,   age ): \n         self . name   =   name \n         self . age   =   age \n\n     def   tell ( self ): \n         pass  class   Teacher ( SchoolMember ): \n     def   __init__ ( self ,   name ,   age ,   salary ): \n         SchoolMember . __init__ ( self ,   name ,   age ) \n         self . salary   =   salary \n\n     def   tell ( self ): \n         SchoolMember . tell ( self ) \n         print   Salary:  %d   %   self . salary  class   Student ( SchoolMember ): \n     def   __init__ ( self ,   name ,   age ,   marks ): \n         SchoolMember . __init__ ( self ,   name ,   age ) \n         self . marks   =   marks \n\n     def   tell ( self ): \n         SchoolMember . tell ( self ) \n         print   Marks:  %d   %   self . marks  t   =   Teacher ( Mrs. Shrividya ,   40 ,   30000 )  s   =   Student ( Swaroop ,   22 ,   75 )  t . tell ()  s . tell ()   输出  Salary:  30000 \nMarks:  75   go  package   main  import   fmt  type   SchoolMember   interface   { \n     tell ()  }  type   Teacher   struct   { \n     name   string \n     age   int \n     salary   int  }  type   Student   struct   { \n     name   string \n     age   int \n     marks   int  }  func   ( this   * Teacher )   tell ()   { \n     fmt . Printf ( Salary: %d\\n ,   this . salary )  }  func   ( this   * Student )   tell ()   { \n     fmt . Printf ( Marks: %d\\n ,   this . marks )  }  func   main ()   { \n     var   t   SchoolMember   =   Teacher { Mrs. Shrividya ,   40 ,   30000 } \n     var   s   SchoolMember   =   Student { Swaroop ,   22 ,   75 } \n     t . tell () \n     s . tell ()  }   输出  Salary: 30000\nMarks: 75", 
            "title": "有基类（使用接口）"
        }, 
        {
            "location": "/method/method_main/", 
            "text": "method就是函数，只不过拥有receiver参数（普通函数没有receiver参数）\n\n\nrecevier写在func和method名字之间，比如：\n\n\ntype\n \nVertex\n \nstruct\n \n{\n\n    \nX\n,\n \nY\n \nfloat64\n\n\n}\n\n\n\nfunc\n \n(\nv\n \nVertex\n)\n \nAbs\n()\n \nfloat64\n \n{\n\n\n    \nreturn\n \nmath\n.\nSqrt\n(\nv\n.\nX\n*\nv\n.\nX\n \n+\n \nv\n.\nY\n*\nv\n.\nY\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nVertex\n{\n3\n,\n \n4\n}\n\n    \nfmt\n.\nPrintln\n(\na\n.\nAbs\n())\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\n上面v Vertex就是recevier\n\n\n高亮的这行代码可以解读为：Abs method拥有一个类型为Vertex，名字为v的receiver\n\n\n\n\n注意：\n\n\n\n\n\n\n内置type不能作为receiver\n\n\nfunc\n \n(\na\n \nint\n)\n \nfoo\n()\n \nint\n \n{\n\n    \nreturn\n \na\n \n+\n \n1\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ni\n \n:=\n \n1\n\n    \nf\n \n:=\n \ni\n.\nfoo\n()\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n}\n\n\n\n\n\n报错\n\n\ncannot define new methods on non-local type int\n\n\n\n\n\n\n\n\n同一个包里自定义的type，才能作为method的receiver\n\n\n$GOPATH/src/github.com/cyent/golang/example/foo.go\n\n\npackage\n \nfoo\n\n\n\ntype\n \nMyInt\n \nint\n\n\n\n\n\nbar.go\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \ngithub.com/cyent/golang/example/foo\n\n\n)\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nfoo\n.\nMyInt\n(\n1\n)\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n1\n\n\n\n\n但如果把bar.go改成\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \ngithub.com/cyent/golang/example/foo\n\n\n)\n\n\n\nfunc\n \n(\nx\n \nfoo\n.\nMyInt\n)\n \nmymethod\n()\n \nint\n \n{\n\n    \nreturn\n \nint\n(\nx\n+\n1\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \na\n \n:=\n \nfoo\n.\nMyInt\n(\n1\n)\n\n    \nfmt\n.\nPrintln\n(\na\n)\n\n\n    \nb\n \n:=\n \na\n.\nmymethod\n()\n\n    \nfmt\n.\nPrintln\n(\nb\n)\n\n\n}\n\n\n\n\n\n报错\n\n\n./bar.go:8: cannot define new methods on non-local type foo.MyInt\n./bar.go:16: a.mymethod undefined (type foo.MyInt has no field or method mymethod)\n\n\n\n\n上面这个例子说明了导入的包里的自定义type可以用（type首字母大写），但不能作为method的receiver\n\n\n\n\n\n\n只有放在包级别的type，并且首字母大写的，才能被导入给其他模块引用，详见\n数据类型章节-自定义类型\n的第4点", 
            "title": "2.1. 声明"
        }, 
        {
            "location": "/method/method_receiver/", 
            "text": "receiver可以使用指针\n\n\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nMyStruct\n \nstruct\n \n{\n\n    \nx\n \nint\n\n\n}\n\n\n\nfunc\n \n(\nm\n \nMyStruct\n)\n \nSet1\n()\n \n{\n\n    \nm\n.\nx\n \n=\n \n1\n\n\n}\n\n\n\nfunc\n \n(\nm\n \n*\nMyStruct\n)\n \nSet2\n()\n \n{\n\n    \nm\n.\nx\n \n=\n \n2\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ns\n \n:=\n \nMyStruct\n{\nx\n:\n \n0\n}\n\n    \ns\n.\nSet1\n()\n\n    \nfmt\n.\nPrintln\n(\ns\n.\nx\n)\n\n    \ns\n.\nSet2\n()\n\n    \nfmt\n.\nPrintln\n(\ns\n.\nx\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n0\n2\n\n\n\n\n可以看出，Set1并没有修改值，Set2才修改了值，是因为指针receiver才是修改原来的值，否则只是复制变量出来成为函数里的局部变量\n\n\nfunction argument、method receiver、method argument关于pointer的区别\n\n\n\n\nfunction的argument和method的receiver都能接收pointer，区别：\n\n\n\n\n\n\nfunction的argument类型必须和传入的类型一致，比如argument是pointer类型，则传入参数也必须是pointer，如果传入参数不是pointer类型，则传入参数不能是pointer。\n\n\n\n\n\n\nmethod的receiver类型比较智能，如果receiver类型是pointer，那么当传入参数类型不是pointer时候，go会自动转为pointer。如果receiver类型不是pointer，那么当传入参数类型是pointer，会自动将pointer转换为pointer所对应的值。\n\n\n\n\nWarning\n\n\n接口的receiver类型必须和实现接口一致，否则会报错，详见\n接口章节部分\n\n\n\n\n如果将上面的例子稍微修改下\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nMyStruct\n \nstruct\n \n{\n\n    \nx\n \nint\n\n\n}\n\n\n\nfunc\n \n(\nm\n \nMyStruct\n)\n \nSet1\n()\n \n{\n\n    \nm\n.\nx\n \n=\n \n1\n\n\n}\n\n\n\nfunc\n \n(\nm\n \n*\nMyStruct\n)\n \nSet2\n()\n \n{\n\n    \nm\n.\nx\n \n=\n \n2\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n\n    \ns\n \n:=\n \nMyStruct\n{\nx\n:\n \n0\n}\n\n\n    \ns\n.\nSet1\n()\n\n    \nfmt\n.\nPrintln\n(\ns\n.\nx\n)\n\n    \ns\n.\nSet2\n()\n\n    \nfmt\n.\nPrintln\n(\ns\n.\nx\n)\n\n\n}\n\n\n\n\n\n输出不变，也是\n\n\n0\n2\n\n\n\n\n上面的\ns.Set1()\n会被go自动转为\n(*s).Set1()\n\n\n同理，如果改为\ns := MyStruct{x: 0}\n，那么\ns.Set2()\n会被go自动转为\n(\ns).Set2()\n\n\n\n\n\n\nmethod argument和function argument是相同的，类型必须一致\n\n\n\n\nNote\n\n\nreceiver在其他语言以及go语言里也叫做 \n函数签名\n（函数签名是最普遍的叫法）\n\n\n\n\n如何判断receiver是否要用指针\n\n\n\n\nmethod的value receiver和pointer receiver怎么选择，官方说了2个原因来使用pointer receiver\n\n\n\n\n\n\n需要修改原来的值\n\n\n\n\n\n\n防止每次调用method时候都拷贝value，比如当struct很大的时候每次都拷贝value会降低效率\n\n\n\n\n\n\n下面是我个人理解，不一定准确：\n\n\n实际应用中，有一个情况是不能用pointer receiver：pointer可能造成安全风险，例如某个method只是要获取金额，而不是修改金额，那么使用pointer的话就存在当内存被泄露等情况导致金额被修改。\n\n\n因此，若没有涉及性能问题，且method的功能是读，而非写的时候，首选value receiver", 
            "title": "2.2. 指针receiver"
        }, 
        {
            "location": "/method/method_receiver/#receiver", 
            "text": "package   main  import   fmt  type   MyStruct   struct   { \n     x   int  }  func   ( m   MyStruct )   Set1 ()   { \n     m . x   =   1  }  func   ( m   * MyStruct )   Set2 ()   { \n     m . x   =   2  }  func   main ()   { \n     s   :=   MyStruct { x :   0 } \n     s . Set1 () \n     fmt . Println ( s . x ) \n     s . Set2 () \n     fmt . Println ( s . x )  }   输出  0\n2  可以看出，Set1并没有修改值，Set2才修改了值，是因为指针receiver才是修改原来的值，否则只是复制变量出来成为函数里的局部变量", 
            "title": "receiver可以使用指针"
        }, 
        {
            "location": "/method/method_receiver/#function-argumentmethod-receivermethod-argumentpointer", 
            "text": "function的argument和method的receiver都能接收pointer，区别：    function的argument类型必须和传入的类型一致，比如argument是pointer类型，则传入参数也必须是pointer，如果传入参数不是pointer类型，则传入参数不能是pointer。    method的receiver类型比较智能，如果receiver类型是pointer，那么当传入参数类型不是pointer时候，go会自动转为pointer。如果receiver类型不是pointer，那么当传入参数类型是pointer，会自动将pointer转换为pointer所对应的值。   Warning  接口的receiver类型必须和实现接口一致，否则会报错，详见 接口章节部分   如果将上面的例子稍微修改下  package   main  import   fmt  type   MyStruct   struct   { \n     x   int  }  func   ( m   MyStruct )   Set1 ()   { \n     m . x   =   1  }  func   ( m   * MyStruct )   Set2 ()   { \n     m . x   =   2  }  func   main ()   {       s   :=   MyStruct { x :   0 }       s . Set1 () \n     fmt . Println ( s . x ) \n     s . Set2 () \n     fmt . Println ( s . x )  }   输出不变，也是  0\n2  上面的 s.Set1() 会被go自动转为 (*s).Set1()  同理，如果改为 s := MyStruct{x: 0} ，那么 s.Set2() 会被go自动转为 ( s).Set2()    method argument和function argument是相同的，类型必须一致   Note  receiver在其他语言以及go语言里也叫做  函数签名 （函数签名是最普遍的叫法）", 
            "title": "function argument、method receiver、method argument关于pointer的区别"
        }, 
        {
            "location": "/method/method_receiver/#receiver_1", 
            "text": "method的value receiver和pointer receiver怎么选择，官方说了2个原因来使用pointer receiver    需要修改原来的值    防止每次调用method时候都拷贝value，比如当struct很大的时候每次都拷贝value会降低效率    下面是我个人理解，不一定准确：  实际应用中，有一个情况是不能用pointer receiver：pointer可能造成安全风险，例如某个method只是要获取金额，而不是修改金额，那么使用pointer的话就存在当内存被泄露等情况导致金额被修改。  因此，若没有涉及性能问题，且method的功能是读，而非写的时候，首选value receiver", 
            "title": "如何判断receiver是否要用指针"
        }, 
        {
            "location": "/method/interface_main/", 
            "text": "接口类型是由一组方法定义的集合。\n\n\n\n\n\n\n接口类型的值可以存放实现这些方法的任何值。\n\n\n\n\n\n\n接口不是被调用者来写，而是调用者来写\n\n\n\n\n\n\ngo语言的设计哲学认为：功能实现者的责任只要提供具体功能，用哪些interface来对功能做抽象是使用者的自由。功能实现者没有办法确定使用者会对自己提供的功能做哪些抽象，所以功能实现者不应该也没有能力设定接口。\n\n\n例如：自己的代码要调用模块A，那么接口是自己来写，而不是模块A来写，即模块A里只有一堆的struct和其方法，自己写接口来封装这些struct方法是为了让自己的代码写起来更灵活（解耦）。", 
            "title": "3.1. 什么是接口"
        }, 
        {
            "location": "/method/interface_syntax/", 
            "text": "不用interface时候\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nMyStruct\n \nstruct\n \n{\n\n    \nX\n,\n \nY\n \nint\n\n\n}\n\n\n\nfunc\n \n(\na\n \n*\nMyStruct\n)\n \nadd\n()\n \nint\n \n{\n\n    \nreturn\n \na\n.\nX\n \n+\n \na\n.\nY\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ns\n \n:=\n \nMyStruct\n{\n3\n,\n \n4\n}\n\n    \nfmt\n.\nPrintln\n(\ns\n.\nadd\n())\n\n\n}\n\n\n\n\n\n输出\n\n\n7\n\n\n\n\n\n\n\n\n现在用interface\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nAdder\n \ninterface\n \n{\n\n\n    \nadd\n()\n \nint\n\n\n}\n\n\n\n\ntype\n \nMyStruct\n \nstruct\n \n{\n\n    \nX\n,\n \nY\n \nint\n\n\n}\n\n\n\nfunc\n \n(\na\n \n*\nMyStruct\n)\n \nadd\n()\n \nint\n \n{\n\n    \nreturn\n \na\n.\nX\n \n+\n \na\n.\nY\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n\n    \nvar\n \nf\n \nAdder\n\n\n    \ns\n \n:=\n \nMyStruct\n{\n3\n,\n \n4\n}\n\n\n    \nf\n \n=\n \ns\n\n\n    \nfmt\n.\nPrintln\n(\nf\n.\nadd\n())\n\n\n}\n\n\n\n\n\n上面黄色高亮部分就是接口部分\n\n\n\n\n简写\n\n\nvar\n \nf\n \nAdder\n\n\ns\n \n:=\n \nMyStruct\n{\n3\n,\n \n4\n}\n\n\nf\n \n=\n \ns\n\n\n\n\n\n可以写成\n\n\nvar\n \nf\n \nAdder\n \n=\n \nMyStruct\n{\n3\n,\n \n4\n}\n\n\n\n\n\n\n\n输出\n\n\n7", 
            "title": "3.2. 接口语法"
        }, 
        {
            "location": "/method/interface_why/", 
            "text": "没有interface时候:\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nDriver\n \nstruct\n \n{\n\n    \nName\n \nstring\n\n\n}\n\n\n\ntype\n \nBenz\n \nstruct\n{}\n\n\n\nfunc\n \n(\nthis\n \n*\nBenz\n)\n \nDrive\n(\ndr\n \nDriver\n)\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%s drives Benz.\\n\n,\n \ndr\n.\nName\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nme\n \n:=\n \nDriver\n{\nName\n:\n \nCyent\n}\n\n\n    \n// 开Benz\n\n    \ncar\n \n:=\n \nBenz\n{}\n\n    \ncar\n.\nDrive\n(\nme\n)\n\n\n}\n\n\n\n\n\n\n\n注意上面main函数里写了多少行，这里一共有3行有效代码\n\n\n\n\n输出\n\n\nCyent drives Benz.\n\n\n\n\n\n\n\n\n现在增加一辆Audi\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nDriver\n \nstruct\n \n{\n\n    \nName\n \nstring\n\n\n}\n\n\n\ntype\n \nBenz\n \nstruct\n{}\n\n\n\nfunc\n \n(\nthis\n \n*\nBenz\n)\n \nDrive\n(\ndr\n \nDriver\n)\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%s drives Benz.\\n\n,\n \ndr\n.\nName\n)\n\n\n}\n\n\n\ntype\n \nAudi\n \nstruct\n \n{}\n\n\n\nfunc\n \n(\nthis\n \n*\nAudi\n)\n \nDrive\n(\ndr\n \nDriver\n)\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%s drives Audi.\\n\n,\n \ndr\n.\nName\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nme\n \n:=\n \nDriver\n{\nName\n:\n \nCyent\n}\n\n\n    \n// car为外部传递进来的值，假设传进来的是Audi\n\n    \nget_car\n \n:=\n \nAudi\n\n    \nswitch\n \nget_car\n \n{\n\n    \ncase\n \nBenz\n:\n\n        \ncar\n \n:=\n \nBenz\n{}\n\n        \ncar\n.\nDrive\n(\nme\n)\n\n    \ncase\n \nAudi\n:\n\n        \ncar\n \n:=\n \nAudi\n{}\n\n        \ncar\n.\nDrive\n(\nme\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n注意：\n\n\n\n\n\n\n由于case里是局部变量作用域，因此\ncar.Drive(me)\n只能放在case里面，无法放在switch外（python是可以的）。因此这种写法也不友好\n\n\n\n\n\n\n注意上面main函数里用了switch可以对传递进来的变量做判断，但这么写也不够好，因为每增加一辆车，switch都要多加一个case，那有没有无论增加多少辆车，main函数永远不用改代码的办法呢，当然有，接下来该interface上场了\n\n\n\n\n\n\n\n\n\n\n使用interface\n\n\npackage\n \nmain\n\n\n\nimport\n \n(\n\n    \nfmt\n\n    \nerrors\n\n\n)\n\n\n\ntype\n \nCar\n \ninterface\n \n{\n\n    \nDrive\n(\nDriver\n)\n\n\n}\n\n\n\nfunc\n \nNewCar\n(\nc\n \nstring\n)\n \n(\nCar\n,\n \nerror\n)\n \n{\n\n    \nswitch\n \nc\n \n{\n\n    \ncase\n \nBenz\n:\n\n        \nreturn\n \nBenz\n{},\n \nnil\n\n    \ncase\n \nAudi\n:\n\n        \nreturn\n \nAudi\n{},\n \nnil\n\n    \ndefault\n:\n\n        \nreturn\n \nnil\n,\n \nerrors\n.\nNew\n(\nnot support\n)\n\n    \n}\n\n\n    \nreturn\n \nnil\n,\n \nerrors\n.\nNew\n(\nnot support\n)\n\n\n}\n\n\n\ntype\n \nDriver\n \nstruct\n \n{\n\n    \nName\n \nstring\n\n\n}\n\n\n\ntype\n \nBenz\n \nstruct\n{}\n\n\n\nfunc\n \n(\nthis\n \n*\nBenz\n)\n \nDrive\n(\ndr\n \nDriver\n)\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%s drives Benz.\\n\n,\n \ndr\n.\nName\n)\n\n\n}\n\n\n\ntype\n \nAudi\n \nstruct\n \n{}\n\n\n\nfunc\n \n(\nthis\n \n*\nAudi\n)\n \nDrive\n(\ndr\n \nDriver\n)\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%s drives Audi.\\n\n,\n \ndr\n.\nName\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nme\n \n:=\n \nDriver\n{\nName\n:\n \nCyent\n}\n\n\n    \n// 外部传递进来的值，假设传进来的是Audi\n\n    \ncar\n,\n \nerr\n \n:=\n \nNewCar\n(\nAudi\n)\n\n    \nif\n \nerr\n \n!=\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\nerr\n)\n\n    \n}\n \nelse\n \n{\n\n        \ncar\n.\nDrive\n(\nme\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n输出\n\n\nCyent drives Audi.\n\n\n\n\n注意: 上面main函数里没有明文提到具体什么车，因此无论增加多少辆车，main函数里的代码可以长久不变，这就是将开车和具体开什么车在main函数里做了解耦", 
            "title": "3.3. Why interface"
        }, 
        {
            "location": "/method/interface_oo/", 
            "text": "golang中没有面向对象，但却可以实现面向对象的基础功能，类比如下：\n\n\n\n\n\n\n基类：golang中的接口相当于面向对象中的基类（虽然接口并不完全是基类的概念，但在某些情况下，会把接口当作基类来使用），只不过继承基类需要显式，而golang的接口是隐式，并且只是方法名和传入传出参数相同即可\n\n\n\n\n\n\n类：golang中的struct相当于面向对象中的类\n\n\n\n\n\n\n类的属性：golang中struct的元素相当于面向对象中类的属性\n\n\n\n\n\n\n类的方法：golang中struct的方法（就叫method，在某些语言里叫签名函数）相当于面向中的类的方法\n\n\n\n\n\n\n例子详见\n比较python和go的面向对象写法", 
            "title": "3.4. 接口和面向对象的关系"
        }, 
        {
            "location": "/method/interface_application/", 
            "text": "interface的使用要满足2个条件才有意义：\n\n\n\n\n\n\n实现了interface的几个struct是相似关系（比如docker和kvm都是虚拟机）、平级的，并且输入输出参数完全一致。（这点是interface的本质，能实现interface的肯定是满足这个条件）\n\n\n\n\n\n\n在业务逻辑上，调用实现interface的struct是不确定的，是通过某种方式传递进来，而不是顺序的业务逻辑，比如\n这样是不对的，因为netns_struct、bridge_struct、veth_struct是有顺序的（先有netns、bridge，才能有veth）：\n\n\n\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \ni\n \nvnic\n\n    \ni\n \n=\n \nnetns_struct\n{\n...\n}\n\n    \ni\n.\nAdd\n()\n\n    \ni\n \n=\n \nbridge_struct\n{\n...\n}\n\n    \ni\n.\nAdd\n()\n\n    \ni\n \n=\n \nveth_struct\n{\n...\n}\n\n    \ni\n.\nAdd\n()\n\n\n}\n\n\n\n\n\n这样逻辑是正确的：\n\n\nvar\n \ni\n \nvnic\n\n\nswitch\n \nopt\n \n{\n\n\ncase\n \nnetns\n:\n\n    \ni\n \n=\n \nnetns\n.\nstruct\n{}\n\n\ncase\n \nbridge\n:\n\n    \ni\n \n=\n \nbridge\n.\nstruct\n{}\n\n\ncase\n \nveth\n:\n\n    \ni\n \n=\n \nveth\n.\nstruct\n{}\n\n\n}\n\n\ni\n.\nAdd\n()\n\n\ni\n.\nDel\n()\n\n\n\n\n\n就是说调用者这方对于实现interface的struct是根据某个参数（通过API传递过来，或者配置文件传递过来，或者etcd传递过来）来选择某个struct，这种逻辑才适用interface。而在vrouter程序逻辑里，netns、bridge、veth是被调用者依次执行，因此不适用interface。\n\n\n总结适用interface的调用者业务逻辑（伪代码）：\n\n\ntype\n \nI\n \ninterface\n \n{\n\n    \n...\n\n\n}\n\n\n\nvar\n \ni\n \nI\n\n\nswitch\n \nopt\n \n{\n    \n//opt通过某种方式传递进来，而不是写死\n\n\ncase\n \nA\n:\n\n    \ni\n \n=\n \nstructA\n{\n...\n}\n\n\ncase\n \nB\n:\n\n    \ni\n \n=\n \nstructB\n{\n...\n}\n\n\ncase\n \nC\n:\n\n    \ni\n \n=\n \nstructC\n{\n...\n}\n\n\ndefault\n:\n\n    \nerrors\n.\nNew\n(\nnot support\n)\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\ninterface使用起来有无数种变形方式，但无论是那种，都要符合上面说的平行选一的业务逻辑。比如\ngolang-targz脑图\n（点击下载，并使用iThoughtsX打开），其中archive/tar/writer.go里\n\n\nfunc NewWriter(w io.Writer) *Writer { return \nWriter{w: w} }\n\n\n\n\n这里用\nw io.Writer\n就是因为有多种压缩方式，有gzip、有bzip2等等许多种，但无论哪种，都实现了io.Writer", 
            "title": "3.5. 应用场景"
        }, 
        {
            "location": "/method/interface_argv/", 
            "text": "如果实现接口的签名函数有传入参数或传出参数，则接口定义时候要带上，比如：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nAdder\n \ninterface\n \n{\n\n    \nAdd\n(\nx\n,\n \ny\n \nint\n)\n \n(\na\n \nint\n)\n\n\n}\n\n\n\ntype\n \nMyStruct\n \nstruct\n \n{\n\n    \nX\n,\n \nY\n \nint\n\n\n}\n\n\n\nfunc\n \n(\nm\n \n*\nMyStruct\n)\n \nAdd\n(\na\n,\n \nb\n \nint\n)\n \nint\n \n{\n\n    \nreturn\n \na\n \n+\n \nb\n \n+\n \nm\n.\nX\n \n+\n \nm\n.\nY\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \nAdder\n\n    \na\n \n=\n \nMyStruct\n{\n3\n,\n \n4\n}\n\n    \nres\n \n:=\n \na\n.\nAdd\n(\n5\n,\n \n6\n)\n\n    \nfmt\n.\nPrintln\n(\nres\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n18\n\n\n\n\n\n\nNote\n\n\n上面的\n\n\ntype\n \nAdder\n \ninterface\n \n{\n\n    \nAdd\n(\nx\n,\n \ny\n \nint\n)\n \n(\na\n \nint\n)\n\n\n}\n\n\n\n\n\n可以改为\n\n\ntype\n \nAdder\n \ninterface\n \n{\n\n    \nAdd\n(\nint\n,\n \nint\n)\n \n(\na\n \nint\n)\n\n\n}\n\n\n\n\n\n也可以改为\n\n\ntype\n \nAdder\n \ninterface\n \n{\n\n    \nAdd\n(\na\n,\nb\n \nint\n)\n \n(\nx\n \nint\n)\n\n\n}\n\n\n\n\n\n也可以改为\n\n\ntype\n \nAdder\n \ninterface\n \n{\n\n    \nAdd\n(\na\n,\n \nb\n \nint\n)\n \n(\nint\n)\n\n\n}\n\n\n\n\n\n但是输入和输出参数不能存在相同变量名，比如下面这样就会报错：\n\n\ntype\n \nAdder\n \ninterface\n \n{\n\n    \nAdd\n(\nx\n,\n \ny\n \nint\n)\n \n(\nx\n \nint\n)\n\n\n}\n\n\n\n\n\n报错\n\n\nduplicate argument x", 
            "title": "3.6. 传入和传出参数要带上"
        }, 
        {
            "location": "/method/interface_receiver/", 
            "text": "用interface.method和直接用自定义TYPE.method()有一点不同要注意：\n\n\n如果用interface.method()，那么method的receiver参数类型必须和实现interface时候的类型相同，比如：\n\n\ntype\n \nI\n \ninterface\n \n{\n\n    \nM\n()\n\n\n}\n\n\n\ntype\n \nT\n \nstruct\n \n{\n\n    \nS\n \nstring\n\n\n}\n\n\n\nfunc\n \n(\nt\n \n*\nT\n)\n \nM\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nt\n.\nS\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \ni\n \nI\n\n    \ni\n \n=\n \nT\n{\nhello\n}\n \n//不能写成i = T{\nhello\n}\n\n    \ni\n.\nM\n()\n\n\n}\n\n\n\n\n\n但如果是直接用method()，就不用类型一致，会自动判断，比如：\n\n\ntype\n \nT\n \nstruct\n \n{\n\n    \nS\n \nstring\n\n\n}\n\n\n\nfunc\n \n(\nt\n \n*\nT\n)\n \nM\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\nt\n.\nS\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ni\n \n:=\n \nT\n{\nhello\n}\n \n//也可以写成i := \nT{\nhello\n}\n\n    \ni\n.\nM\n()\n\n\n}\n\n\n\n\n\n这2个例子的输出都是hello", 
            "title": "3.7. 接口receiver参数类型不会自动转换"
        }, 
        {
            "location": "/method/interface_implement/", 
            "text": "如果一个类型实现了一个接口的所有方法，那么就说这个类型实现了这个接口\n\n\ntype\n \nFile\n \ninterface\n \n{\n\n    \nRead\n(\nb\n \nBuffer\n)\n \nbool\n\n    \nWrite\n(\nb\n \nBuffer\n)\n \nbool\n\n    \nClose\n()\n\n\n}\n\n\n\ntype\n \nT\n \nstruct\n \n{\n\n    \n...\n\n\n}\n\n\n\nfunc\n \n(\np\n \nT\n)\n \nRead\n(\nb\n \nBuffer\n)\n \nbool\n \n{\n \nreturn\n \n...\n \n}\n\n\nfunc\n \n(\np\n \nT\n)\n \nWrite\n(\nb\n \nBuffer\n)\n \nbool\n \n{\n \nreturn\n \n...\n \n}\n\n\nfunc\n \n(\np\n \nT\n)\n \nClose\n()\n \n{\n \n...\n \n}\n\n\n\n\n\n上面例子可以这么描述：类型T实现了File接口的所有方法（即Read()、Write()、Close()），因此可以说类型T实现了接口File\n\n\n\n\n\n\n某类型实现某方法：比如上面这个例子，可以说类型T实现了方法Read()、Write()、Close()", 
            "title": "3.8. 各种实现"
        }, 
        {
            "location": "/method/interface_nil/", 
            "text": "nil interface的官方解释：Interface values with nil underlying values\n\n\n只有声明了但没赋值的interface才是nil interface，只要赋值了，即使赋了一个nil类型，也不是nil interface了\n\n\n\n\nCalling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.\n\n\n\n\nnil interface是不能调用方法的，如果调用方法，比如xxx是个nil interface，那么xxx.M()会runtime error。\n\n\n另外，如果interface的值是空的，那么这个interface的值类型就是\n，这时候.method()来调用方法的话，传递进去的receiver的值类型也将是nil\n\n\n注意，这种情况下，如果method里再调用，就会抛出运行时异常\n\n\n举例：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nI\n \ninterface\n \n{\n\n    \nM\n()\n\n\n}\n\n\n\ntype\n \nT\n \nstruct\n \n{\n\n    \nS\n \nstring\n\n\n}\n\n\n\nfunc\n \n(\nt\n \n*\nT\n)\n \nM\n()\n \n{\n\n    \nif\n \nt\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\nnil\n)\n\n        \nreturn\n\n    \n}\n\n    \nfmt\n.\nPrintln\n(\nt\n.\nS\n)\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \ni\n \nI\n\n\n    \nvar\n \nt\n \n*\nT\n\n    \ni\n \n=\n \nt\n\n    \ndescribe\n(\ni\n)\n\n    \ni\n.\nM\n()\n\n\n    \ni\n \n=\n \nT\n{\nhello\n}\n\n    \ndescribe\n(\ni\n)\n\n    \ni\n.\nM\n()\n\n\n}\n\n\n\nfunc\n \ndescribe\n(\ni\n \nI\n)\n \n{\n\n    \nfmt\n.\nPrintf\n(\n(%v, %T)\\n\n,\n \ni\n,\n \ni\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n(\nnil\n, *main.T)\n\nnil\n\n(\n{hello}, *main.T)\nhello\n\n\n\n\n如果把上面M()里面的return这行注释掉，则会输出\n\n\n(\nnil\n, *main.T)\n\nnil\n\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xc8971]\n\ngoroutine 1 [running]:\nmain.(*T).M(0x0, 0x0)\n    /tmp/sandbox104196984/main.go:18 +0x31\nmain.main()\n    /tmp/sandbox104196984/main.go:27 +0x60\n\n\n\n\n\n\nIf the concrete value inside the interface itself is nil, the method will be called with a nil receiver.\n\n\nIn some languages this would trigger a null pointer exception, but in Go it is common to write methods that gracefully handle being called with a nil receiver (as with the method M in this example.)\n\n\nNote that an interface value that holds a nil concrete value is itself non-nil.\n\n\n\n\n上面是官网的话，其中最后一句，是说当声明一个interface时候，这个interface是nil，然后给这个interface赋了一个为nil的变量时候，这个interface就不是nil。测试例子：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nI\n \ninterface\n \n{\n\n    \nM\n()\n\n\n}\n\n\n\ntype\n \nT\n \n[]\nint\n\n\n\nfunc\n \n(\nt\n \nT\n)\n \nM\n()\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%T\\n\n,\n \nt\n)\n\n    \nif\n \nt\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\nnil\n)\n\n        \nreturn\n\n    \n}\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \nT\n\n    \nfmt\n.\nPrintf\n(\n%T %v\\n\n,\n \na\n,\n \na\n)\n\n    \nif\n \na\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\na is nil\n)\n\n    \n}\n\n\n    \nvar\n \ni\n \nI\n\n    \nif\n \ni\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\ni is nil\n)\n\n    \n}\n\n\n    \ni\n \n=\n \na\n\n    \nif\n \ni\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\ni is nil also.\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n输出\n\n\nmain.T []\na is nil\ni is nil", 
            "title": "3.9. nil interface"
        }, 
        {
            "location": "/other/string/", 
            "text": "字符串拼接\n\n\n\n\n将string类型的slice中的元素用指定字符拼接起来\n\n\nstrings.Join(sli, \n \n)\n\n\n\n\n表示将sli中的各个元素用一个空格拼接在一起形成一个string\n\n\n\n\nWarning\n\n\n仅支持[]string，不支持array，也不支持[]int", 
            "title": "1. 字符串处理"
        }, 
        {
            "location": "/other/string/#_1", 
            "text": "将string类型的slice中的元素用指定字符拼接起来  strings.Join(sli,    )  表示将sli中的各个元素用一个空格拼接在一起形成一个string   Warning  仅支持[]string，不支持array，也不支持[]int", 
            "title": "字符串拼接"
        }, 
        {
            "location": "/other/range/", 
            "text": "range主要用于for循环，用来迭代取出slice或map的元素\n\n\n用于slice时候，会返回2个值：\n\n\n\n\n\n\n第一个值是元素下标，比如第一个元素的下标是0\n\n\n\n\n\n\n第二个值是元素内容\n\n\n\n\n\n\n\n\n对slice用range时候取的是可见元素，即不超过len范围，而不是cap元素。因为可见元素才有值，cap只是容量，超出可见部分是没有值的。\n\n\n\n\n举例\n\n\npow\n \n:=\n \n[]\nint\n{\n2\n,\n \n3\n,\n \n5\n,\n \n7\n,\n \n11\n,\n \n13\n}\n\n\nfor\n \ni\n,\n \nv\n \n:=\n \nrange\n \npow\n \n{\n\n    \nfmt\n.\nPrintf\n(\nindex=%d, value=%d\\n\n,\n \ni\n,\n \nv\n)\n\n\n}\n\n\n\n\n\n输出\n\n\nindex=0, value=2\nindex=1, value=3\nindex=2, value=5\nindex=3, value=7\nindex=4, value=11\nindex=5, value=13\n\n\n\n\n可以用下划线_作为占位符，表示不需要取值\n\n\n如果只想取index，不想取value，可以不写\n, value\n，比如\n\n\npow\n \n:=\n \nmake\n([]\nint\n,\n \n10\n)\n\n\nfor\n \ni\n \n:=\n \nrange\n \npow\n \n{\n\n    \npow\n[\ni\n]\n \n=\n \n1\n \n \nuint\n(\ni\n)\n \n// == 2**i\n\n\n}\n\n\nfor\n \n_\n,\n \nvalue\n \n:=\n \nrange\n \npow\n \n{\n\n    \nfmt\n.\nPrintf\n(\n%d\\n\n,\n \nvalue\n)\n\n\n}\n\n\n\n\n\n输出\n\n\n1\n2\n4\n8\n16\n32\n64\n128\n256\n\n\n\n\n\n\n关于左移和右移运算符\n\n\n左移运算符\n\n\n右移运算符", 
            "title": "2. range"
        }, 
        {
            "location": "/other/sync_block/", 
            "text": "同步、异步是一对:\n\n\n\n\n\n\n同步: 排队\n\n\n\n\n\n\n异步: 领号码条，等待叫号\n\n\n\n\n\n\n阻塞、非阻塞是一对:\n\n\n\n\n\n\n阻塞: 只能做一件事\n\n\n\n\n\n\n非阻塞: 做一件事同时可以做其他事\n\n\n\n\n\n\n同步、异步，与阻塞、非阻塞，没有必然联系\n\n\n组合举例:\n\n\n\n\n\n\n同步阻塞: 专心排队，其他任何事都做不了。效率低下\n\n\n\n\n\n\n同步非阻塞: 排队过程中玩手机，时不时看队伍排到自己没有。不停切换，效率低下\n\n\n\n\n\n\n异步阻塞: 领号码条，直到叫号，期间任何其他事都做不了\n\n\n\n\n\n\n异步非阻塞: 领号码条，在叫号之前可以玩手机，效率最高", 
            "title": "3. 同步异步与阻塞非阻塞的关系"
        }, 
        {
            "location": "/other/binary_operation/", 
            "text": "左移运算符\n\n\n\n\nx \n y\n\n\n\n\n表示将x的二进制整个左移y位，可以理解为原来不动，然后在最右边加y个0\n\n\n比如100 \n 2为400，因为100的二进制是1100100，左移2位就是110010000，即400\n\n\n右移运算符\n\n\n\n\nx \n y\n\n\n\n\n表示将y的二进制整个右移y位，超出边界的就遗弃掉，全部超出边界的就为0\n\n\n比如400 \n 2为100，因为400的二进制是110010000，右移2位就是1100100，即十进制的100\n\n\n比如二进制的101，右移2位就是1，也即十进制的1，但如果是右移3位就是0", 
            "title": "4. 位运算"
        }, 
        {
            "location": "/other/binary_operation/#_1", 
            "text": "x   y  表示将x的二进制整个左移y位，可以理解为原来不动，然后在最右边加y个0  比如100   2为400，因为100的二进制是1100100，左移2位就是110010000，即400", 
            "title": "左移运算符&lt;&lt;"
        }, 
        {
            "location": "/other/binary_operation/#_2", 
            "text": "x   y  表示将y的二进制整个右移y位，超出边界的就遗弃掉，全部超出边界的就为0  比如400   2为100，因为400的二进制是110010000，右移2位就是1100100，即十进制的100  比如二进制的101，右移2位就是1，也即十进制的1，但如果是右移3位就是0", 
            "title": "右移运算符&gt;&gt;"
        }, 
        {
            "location": "/other/loop_iterate_traversal_recursion/", 
            "text": "详细地址：\nhttp://www.nowamagic.net/librarys/veda/detail/2324\n\n\n下面摘录部分内容：\n\n\n\n\n\n\n循环（loop）：指的是在满足条件的情况下，重复执行同一段代码。比如，while语句。\n\n\n\n\n\n\n迭代（iterate）：指的是按照某种顺序逐个访问列表中的每一项。比如，for语句。\n\n\n\n\n\n\n遍历（traversal）：指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。\n\n\n\n\n\n\n递归（recursion）：指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。", 
            "title": "5. 循环、迭代、遍历、递归的区别"
        }, 
        {
            "location": "/other/go_python/", 
            "text": "回调函数\n\n\n\n\n\n\n面向对象\n\n\n\n\n\n\n鸭子类型/接口", 
            "title": "6. go和python的比较"
        }, 
        {
            "location": "/other/oo/", 
            "text": "重载overload与覆盖override\n\n\n\n\nhttp://developer.51cto.com/art/201106/266705.htm\n\n\nOverload是重载的意思，Override是覆盖的意思，也就是重写。\n\n\n重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。\n\n\n重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。\n\n\n【这句话不是很理解】重写override是父类与子类之间多态性的一种表现，重载overload是一个类中多态性的一种表现\n\n\npython没有overload，是因为python是动态语言，python的函数可以传入任意类型和任意数量的参数（可以用*args或**kwargs）。因此python不需要overload【这句话理解不完全对，主要是说明python比较智能和灵活，可以传入任意数量的参数】。\n\n\n多态\n\n\n\n\nhttp://bbs.itheima.com/thread-119448-1-1.html\n\n\n不要把函数重载理解为多态。\n\n\n多态是一种运行期的行为，不是编译期的行为。\n\n\n多态可以理解为 一个事物，多种表现形态。\n\n\n比如一个老师（好比java中一个类，一个描述老师的类），在学生面前他以老师的形态存在，而在他孩子面前以父亲的形式存在，在他妻子面前则以老公的形式存在。\n\n\n例如在java中可以用父类类型的引用指向子类类型\n\n\nObject obj=new String(\na\n);\n\n\n\n\nobj为父类类型引用，用obj指向了子类对象String。\n\n\n不用多态时，这样写\n\n\nString s=new String(\na\n);\n\n\n\n\n即用本类类型引用指向本类类型实例。\n\n\n\n\n关于java中的多态\n\n\n下面2个都是多态：\n\n\n\n\n\n\n父类的引用类型变量指向了子类的对象\n\n\n\n\n\n\n接口类型的引用类型变量指向了接口实现类 的对象。\n\n\n\n\n\n\n以下是第2点的例子：\n\n\n实现关系下的多态：\n接口 变量 = new 接口实现类的对象。\n\n\n//接口的方法全部都是非静态的方法\n\n\ninterface\n \nDao\n{\n\n    \npublic\n \nvoid\n \nadd\n();\n  \n    \npublic\n \nvoid\n \ndelete\n();\n  \n\n}\n  \n\n\n//接口的实现类  \n\n\nclass\n \nUserDao\n \nimplements\n \nDao\n{\n  \n    \npublic\n \nvoid\n \nadd\n(){\n  \n        \nSystem\n.\nout\n.\nprintln\n(\n添加员工成功！！\n);\n  \n    \n}\n   \n    \npublic\n \nvoid\n \ndelete\n(){\n  \n        \nSystem\n.\nout\n.\nprintln\n(\n删除员工成功！！\n);\n  \n    \n}\n  \n\n}\n  \n\n\nclass\n \nDemo3\n   \n\n{\n  \n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n   \n    \n{\n  \n        \n//实现关系下的多态  \n\n        \nDao\n \nd\n \n=\n \nnew\n \nUserDao\n();\n \n//接口的引用类型变量指向了接口实现类的对象。  \n\n        \nd\n.\nadd\n();\n  \n    \n}\n  \n\n}\n\n\n\n\n\n\n\n鸭子类型\n\n\n\n\n介绍\n\n\nhttps://zh.wikipedia.org/wiki/鸭子类型\n\n\nhttp://www.jb51.net/article/116025.htm\n（鸭子类型与多态）\n\n\n当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子\n\n\n在程序设计中，鸭子类型（英语：Duck typing）是动态类型和某些静态语言的一种对象推断风格。\n\n\n在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。\n\n\n鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。\n\n\n个人理解鸭子类型是多态的一种实现方式\n\n\npython鸭子类型\n\n\nhttps://docs.python.org/3/glossary.html#term-duck-typing\n\n\nPython不支持多态，也不用支持多态，python是一种多态语言，崇尚鸭子类型\n\n\n例1\n\n\n#!/usr/bin/env python\n\n\n# -*- coding: utf-8 -*-\n\n\n\ndef\n \ncalculate\n(\na\n,\n \nb\n,\n \nc\n):\n\n    \nreturn\n \n(\na\n+\nb\n)\n*\nc\n\n\n\nexample1\n \n=\n \ncalculate\n(\n1\n,\n \n2\n,\n \n3\n)\n\n\nexample2\n \n=\n \ncalculate\n([\n1\n,\n \n2\n,\n \n3\n],\n \n[\n4\n,\n \n5\n,\n \n6\n],\n \n2\n)\n\n\nexample3\n \n=\n \ncalculate\n(\napples \n,\n \nand oranges, \n,\n \n3\n)\n\n\n\nprint\n \nexample1\n\n\nprint\n \nexample2\n\n\nprint\n \nexample3\n\n\n\n\n\n输出\n\n\n9\n[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]\napples and oranges, apples and oranges, apples and oranges,\n\n\n\n\n\n\n该例子鸭子类型在不使用继承的情况下使用了多态\n\n\n\n\n例2\n\n\n#!/usr/bin/env python\n\n\n# -*- coding: utf-8 -*-\n\n\n\nclass\n \nDuck\n:\n\n    \ndef\n \nquack\n(\nself\n):\n\n        \nprint\n \n这鸭子在呱呱叫\n\n    \ndef\n \nfeathers\n(\nself\n):\n\n        \nprint\n \n这鸭子拥有白色与灰色羽毛\n\n\n\nclass\n \nPerson\n:\n\n    \ndef\n \nquack\n(\nself\n):\n\n        \nprint\n \n这人正在模仿鸭子\n\n    \ndef\n \nfeathers\n(\nself\n):\n\n        \nprint\n \n这人在地上拿起1根羽毛然后給其他人看\n\n\n\ndef\n \nin_the_forest\n(\nduck\n):\n\n    \nduck\n.\nquack\n()\n\n    \nduck\n.\nfeathers\n()\n\n\n\ndef\n \ngame\n():\n\n    \ndonald\n \n=\n \nDuck\n()\n\n    \njohn\n \n=\n \nPerson\n()\n\n    \nin_the_forest\n(\ndonald\n)\n\n    \nin_the_forest\n(\njohn\n)\n\n\n\ngame\n()\n\n\n\n\n\n输出\n\n\n这鸭子在呱呱叫\n这鸭子拥有白色与灰色羽毛\n这人正在模仿鸭子\n这人在地上拿起1根羽毛然后給其他人看\n\n\n\n\ngo鸭子类型\n\n\ngolang中没有class的概念，而是通过interface类型转换支持动态类型语言中常见的鸭子类型，来达到运行时多态的效果。\n\n\n接口可以提供鸭子类型的一些益处，但鸭子类型与之不同的是没有显式定义任何接口。\n\n\n上面python的例子用go可以这么写：\n\n\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\ntype\n \nDucker\n \ninterface\n \n{\n\n    \nquack\n()\n\n    \nfeathers\n()\n\n\n}\n\n\n\ntype\n \nDuck\n \nstruct\n{}\n\n\ntype\n \nPerson\n \nstruct\n{}\n\n\n\nfunc\n \n(\nthis\n \n*\nDuck\n)\n \nquack\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\n这鸭子在呱呱叫\n)\n\n\n}\n\n\n\nfunc\n \n(\nthis\n \n*\nDuck\n)\n \nfeathers\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\n这鸭子拥有白色与灰色羽毛\n)\n\n\n}\n\n\n\nfunc\n \n(\nthis\n \n*\nPerson\n)\n \nquack\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\n这人正在模仿鸭子\n)\n\n\n}\n\n\n\nfunc\n \n(\nthis\n \n*\nPerson\n)\n \nfeathers\n()\n \n{\n\n    \nfmt\n.\nPrintln\n(\n这人在地上拿起1根羽毛然后給其他人看\n)\n\n\n}\n\n\n\nfunc\n \nin_the_forest\n(\nd\n \nDucker\n)\n \n{\n\n    \nd\n.\nquack\n()\n\n    \nd\n.\nfeathers\n()\n\n\n}\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \ndonald\n \n:=\n \nDuck\n{}\n\n    \njohn\n \n:=\n \nPerson\n{}\n\n    \nin_the_forest\n(\ndonald\n)\n\n    \nin_the_forest\n(\njohn\n)\n\n\n}\n\n\n\n\n\n输出也是\n\n\n这鸭子在呱呱叫\n这鸭子拥有白色与灰色羽毛\n这人正在模仿鸭子\n这人在地上拿起1根羽毛然后給其他人看\n\n\n\n\n这2个例子对比，可以直接看出几点区别:\n\n\n\n\n\n\npython无需接口（python是动态语言，没有接口），而go需要接口\n\n\n\n\n\n\npython的in_the_forest无需指定传入参数类型，而go需要（传入参数时候实现了接口）\n\n\n\n\n\n\n泛型编程\n\n\n\n\nhttp://legendtkl.com/2015/11/25/go-generic-programming/\n\n\n抽象类与接口\n\n\n\n\n抽象类（也叫基类）：\n\n\n\n\n\n\n小明在家跟妈妈说，我要吃水果。妈妈去水果摊去买水果，看看哪个便宜就买哪个。最后买回去了橘子。这就叫抽象类。\n\n\n\n\n\n\n你有一辆宝马的汽车，有一天，你拿它去越野了，轮胎，哎，自然爆掉，现在你想换轮胎。你不想换宝马的轮胎，太贵。你不想换qq的轮胎，不好使。你想换奥迪的，换了，好用。这就是抽象类。\n\n\n\n\n\n\n接口：\n\n\n\n\n\n\n你在街上被人群殴，有人用棍子打你，有人用脚踹，有人用拳头。反正你费血了。这就叫接口。\n\n\n\n\n\n\n你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。所有的上述硬件都可以公用这个接口，而且有很好的扩展性。这就是接口\n\n\n\n\n\n\n接口和抽象类都是多态。\n\n\n假设我要拿遥控器打开电器。接口和抽象类多态的侧重点不同。接口的侧重点在遥控器，多态的侧重点在电器\n\n\n横看接口竖看类：横向扩展使用接口；纵向扩展使用抽象基类；横向和纵向都要扩展，使用抽象基类继承接口。\n\n\n\n\n\n\n在差异较大的对象中追求功能上的共性时，使用接口。\n\n\n\n\n\n\n在差异较小的对象中追求功能上的不同时，使用抽象基类，因为抽象基类可以包含实现的成员。\n\n\n\n\n\n\ngolang里的\"面向对象\"\n\n\n\n\n详见接口章节\n\n\n3种代码风格\n\n\n\n\n来自：\nhttps://docs.python.org/3/glossary.html\n 中提到的\n\n\n\n\n\n\nduck typing\n\n\n\n\n\n\nEAFP（Easier to ask for forgiveness than permission）\n\n\n\n\n\n\nLBYL（Look before you leap）\n\n\n\n\n\n\n泛型编程、鸭子类型、interface关系\n\n\n\n\n这段话为个人理解，不保证准确性鸭子类型是一个老外提出的构想，是一种动态的代码风格，某个开发语言支持了这个构想而产生的编程风格或规范，叫做泛型编程，interface是go对泛型编程的实现（准确说是go不支持泛型编程，但go的interface可以实现类似泛型编程的效果）\n\n\n泛型编程：像类一样，泛型也是一种抽象数据类型，但是泛型不属于面向对象，它是面向对象的补充和发展。", 
            "title": "7. 面向对象"
        }, 
        {
            "location": "/other/oo/#overloadoverride", 
            "text": "http://developer.51cto.com/art/201106/266705.htm  Overload是重载的意思，Override是覆盖的意思，也就是重写。  重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。  重写Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。  【这句话不是很理解】重写override是父类与子类之间多态性的一种表现，重载overload是一个类中多态性的一种表现  python没有overload，是因为python是动态语言，python的函数可以传入任意类型和任意数量的参数（可以用*args或**kwargs）。因此python不需要overload【这句话理解不完全对，主要是说明python比较智能和灵活，可以传入任意数量的参数】。", 
            "title": "重载overload与覆盖override"
        }, 
        {
            "location": "/other/oo/#_1", 
            "text": "http://bbs.itheima.com/thread-119448-1-1.html  不要把函数重载理解为多态。  多态是一种运行期的行为，不是编译期的行为。  多态可以理解为 一个事物，多种表现形态。  比如一个老师（好比java中一个类，一个描述老师的类），在学生面前他以老师的形态存在，而在他孩子面前以父亲的形式存在，在他妻子面前则以老公的形式存在。  例如在java中可以用父类类型的引用指向子类类型  Object obj=new String( a );  obj为父类类型引用，用obj指向了子类对象String。  不用多态时，这样写  String s=new String( a );  即用本类类型引用指向本类类型实例。   关于java中的多态  下面2个都是多态：    父类的引用类型变量指向了子类的对象    接口类型的引用类型变量指向了接口实现类 的对象。    以下是第2点的例子：  实现关系下的多态：\n接口 变量 = new 接口实现类的对象。  //接口的方法全部都是非静态的方法  interface   Dao { \n     public   void   add ();   \n     public   void   delete ();    }    //接口的实现类    class   UserDao   implements   Dao {   \n     public   void   add (){   \n         System . out . println ( 添加员工成功！！ );   \n     }    \n     public   void   delete (){   \n         System . out . println ( 删除员工成功！！ );   \n     }    }    class   Demo3     {   \n     public   static   void   main ( String []   args )    \n     {   \n         //实现关系下的多态   \n         Dao   d   =   new   UserDao ();   //接口的引用类型变量指向了接口实现类的对象。   \n         d . add ();   \n     }    }", 
            "title": "多态"
        }, 
        {
            "location": "/other/oo/#_2", 
            "text": "", 
            "title": "鸭子类型"
        }, 
        {
            "location": "/other/oo/#_3", 
            "text": "https://zh.wikipedia.org/wiki/鸭子类型  http://www.jb51.net/article/116025.htm （鸭子类型与多态）  当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子  在程序设计中，鸭子类型（英语：Duck typing）是动态类型和某些静态语言的一种对象推断风格。  在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。  鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。  个人理解鸭子类型是多态的一种实现方式", 
            "title": "介绍"
        }, 
        {
            "location": "/other/oo/#python", 
            "text": "https://docs.python.org/3/glossary.html#term-duck-typing  Python不支持多态，也不用支持多态，python是一种多态语言，崇尚鸭子类型  例1  #!/usr/bin/env python  # -*- coding: utf-8 -*-  def   calculate ( a ,   b ,   c ): \n     return   ( a + b ) * c  example1   =   calculate ( 1 ,   2 ,   3 )  example2   =   calculate ([ 1 ,   2 ,   3 ],   [ 4 ,   5 ,   6 ],   2 )  example3   =   calculate ( apples  ,   and oranges,  ,   3 )  print   example1  print   example2  print   example3   输出  9\n[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6]\napples and oranges, apples and oranges, apples and oranges,   该例子鸭子类型在不使用继承的情况下使用了多态   例2  #!/usr/bin/env python  # -*- coding: utf-8 -*-  class   Duck : \n     def   quack ( self ): \n         print   这鸭子在呱呱叫 \n     def   feathers ( self ): \n         print   这鸭子拥有白色与灰色羽毛  class   Person : \n     def   quack ( self ): \n         print   这人正在模仿鸭子 \n     def   feathers ( self ): \n         print   这人在地上拿起1根羽毛然后給其他人看  def   in_the_forest ( duck ): \n     duck . quack () \n     duck . feathers ()  def   game (): \n     donald   =   Duck () \n     john   =   Person () \n     in_the_forest ( donald ) \n     in_the_forest ( john )  game ()   输出  这鸭子在呱呱叫\n这鸭子拥有白色与灰色羽毛\n这人正在模仿鸭子\n这人在地上拿起1根羽毛然后給其他人看", 
            "title": "python鸭子类型"
        }, 
        {
            "location": "/other/oo/#go", 
            "text": "golang中没有class的概念，而是通过interface类型转换支持动态类型语言中常见的鸭子类型，来达到运行时多态的效果。  接口可以提供鸭子类型的一些益处，但鸭子类型与之不同的是没有显式定义任何接口。  上面python的例子用go可以这么写：  package   main  import   fmt  type   Ducker   interface   { \n     quack () \n     feathers ()  }  type   Duck   struct {}  type   Person   struct {}  func   ( this   * Duck )   quack ()   { \n     fmt . Println ( 这鸭子在呱呱叫 )  }  func   ( this   * Duck )   feathers ()   { \n     fmt . Println ( 这鸭子拥有白色与灰色羽毛 )  }  func   ( this   * Person )   quack ()   { \n     fmt . Println ( 这人正在模仿鸭子 )  }  func   ( this   * Person )   feathers ()   { \n     fmt . Println ( 这人在地上拿起1根羽毛然后給其他人看 )  }  func   in_the_forest ( d   Ducker )   { \n     d . quack () \n     d . feathers ()  }  func   main ()   { \n     donald   :=   Duck {} \n     john   :=   Person {} \n     in_the_forest ( donald ) \n     in_the_forest ( john )  }   输出也是  这鸭子在呱呱叫\n这鸭子拥有白色与灰色羽毛\n这人正在模仿鸭子\n这人在地上拿起1根羽毛然后給其他人看  这2个例子对比，可以直接看出几点区别:    python无需接口（python是动态语言，没有接口），而go需要接口    python的in_the_forest无需指定传入参数类型，而go需要（传入参数时候实现了接口）", 
            "title": "go鸭子类型"
        }, 
        {
            "location": "/other/oo/#_4", 
            "text": "http://legendtkl.com/2015/11/25/go-generic-programming/", 
            "title": "泛型编程"
        }, 
        {
            "location": "/other/oo/#_5", 
            "text": "抽象类（也叫基类）：    小明在家跟妈妈说，我要吃水果。妈妈去水果摊去买水果，看看哪个便宜就买哪个。最后买回去了橘子。这就叫抽象类。    你有一辆宝马的汽车，有一天，你拿它去越野了，轮胎，哎，自然爆掉，现在你想换轮胎。你不想换宝马的轮胎，太贵。你不想换qq的轮胎，不好使。你想换奥迪的，换了，好用。这就是抽象类。    接口：    你在街上被人群殴，有人用棍子打你，有人用脚踹，有人用拳头。反正你费血了。这就叫接口。    你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。所有的上述硬件都可以公用这个接口，而且有很好的扩展性。这就是接口    接口和抽象类都是多态。  假设我要拿遥控器打开电器。接口和抽象类多态的侧重点不同。接口的侧重点在遥控器，多态的侧重点在电器  横看接口竖看类：横向扩展使用接口；纵向扩展使用抽象基类；横向和纵向都要扩展，使用抽象基类继承接口。    在差异较大的对象中追求功能上的共性时，使用接口。    在差异较小的对象中追求功能上的不同时，使用抽象基类，因为抽象基类可以包含实现的成员。", 
            "title": "抽象类与接口"
        }, 
        {
            "location": "/other/oo/#golang", 
            "text": "详见接口章节", 
            "title": "golang里的\"面向对象\""
        }, 
        {
            "location": "/other/oo/#3", 
            "text": "来自： https://docs.python.org/3/glossary.html  中提到的    duck typing    EAFP（Easier to ask for forgiveness than permission）    LBYL（Look before you leap）", 
            "title": "3种代码风格"
        }, 
        {
            "location": "/other/oo/#interface", 
            "text": "这段话为个人理解，不保证准确性鸭子类型是一个老外提出的构想，是一种动态的代码风格，某个开发语言支持了这个构想而产生的编程风格或规范，叫做泛型编程，interface是go对泛型编程的实现（准确说是go不支持泛型编程，但go的interface可以实现类似泛型编程的效果）  泛型编程：像类一样，泛型也是一种抽象数据类型，但是泛型不属于面向对象，它是面向对象的补充和发展。", 
            "title": "泛型编程、鸭子类型、interface关系"
        }, 
        {
            "location": "/other/nil/", 
            "text": "int和[]int nil\n\n\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \nint\n\n    \nif\n \na\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\na is nil\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n输出\n\n\n./nil.go:7: cannot convert nil to type int\n\n\n\n\n修改代码\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \nint\n \n=\n \nnil\n\n    \nif\n \na\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\na is nil\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n输出\n\n\n./nil.go:6: cannot use nil as type int in assignment\n./nil.go:7: cannot convert nil to type int\n\n\n\n\n修改代码\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \n[]\nint\n\n    \nif\n \na\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\na is nil\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n输出\n\n\na is nil\n\n\n\n\n修改代码\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\npackage\n \nmain\n\n\n\nimport\n \nfmt\n\n\n\nfunc\n \nmain\n()\n \n{\n\n    \nvar\n \na\n \n[]\nint\n \n=\n \nnil\n\n    \nif\n \na\n \n==\n \nnil\n \n{\n\n        \nfmt\n.\nPrintln\n(\na is nil\n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n输出\n\n\na is nil\n\n\n\n\n说明不是什么所有类型的变量都能用if xxx == nil来判断是否是nil\n\n\narray和slice nil\n\n\n\n\n详见array slice章节\n\n\nmap nil\n\n\n\n\n详见map章节\n\n\ninterface nil\n\n\n\n\n详见接口章节", 
            "title": "8. nil"
        }, 
        {
            "location": "/other/nil/#intint-nil", 
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 package   main  import   fmt  func   main ()   { \n     var   a   int \n     if   a   ==   nil   { \n         fmt . Println ( a is nil ) \n     }  }    输出  ./nil.go:7: cannot convert nil to type int  修改代码   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 package   main  import   fmt  func   main ()   { \n     var   a   int   =   nil \n     if   a   ==   nil   { \n         fmt . Println ( a is nil ) \n     }  }    输出  ./nil.go:6: cannot use nil as type int in assignment\n./nil.go:7: cannot convert nil to type int  修改代码   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 package   main  import   fmt  func   main ()   { \n     var   a   [] int \n     if   a   ==   nil   { \n         fmt . Println ( a is nil ) \n     }  }    输出  a is nil  修改代码   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 package   main  import   fmt  func   main ()   { \n     var   a   [] int   =   nil \n     if   a   ==   nil   { \n         fmt . Println ( a is nil ) \n     }  }    输出  a is nil  说明不是什么所有类型的变量都能用if xxx == nil来判断是否是nil", 
            "title": "int和[]int nil"
        }, 
        {
            "location": "/other/nil/#arrayslice-nil", 
            "text": "详见array slice章节", 
            "title": "array和slice nil"
        }, 
        {
            "location": "/other/nil/#map-nil", 
            "text": "详见map章节", 
            "title": "map nil"
        }, 
        {
            "location": "/other/nil/#interface-nil", 
            "text": "详见接口章节", 
            "title": "interface nil"
        }, 
        {
            "location": "/other/make/", 
            "text": "array和slice make\n\n\n\n\n详见array slice章节\n\n\nmap make\n\n\n\n\n详见map章节", 
            "title": "9. make"
        }, 
        {
            "location": "/other/make/#arrayslice-make", 
            "text": "详见array slice章节", 
            "title": "array和slice make"
        }, 
        {
            "location": "/other/make/#map-make", 
            "text": "详见map章节", 
            "title": "map make"
        }, 
        {
            "location": "/appendix/doc/", 
            "text": "官方文档\n\n\n\n\n英文(官方网站): \nhttps://golang.org/\n\n\n中文(官方认可的翻译网站): \nhttps://go-zh.org/\n\n\n\n\n注意: 中文网站更新很慢，官网上有的内容在中文网站找不到，因此建议先上英文，有看不懂的时候再参考中文网站\n\n\n\n\ngolang官方FAQ \nhttps://golang.org/doc/faq\n（当对某个概念有疑问或者学习到某个章节时候可以查询卡一下）\n\n\ngo例子（非官方）\nhttps://gobyexample.com\n（上面有很多例子，比如学习json时候可以在上面看下是否有相关例子）", 
            "title": "1. 文档"
        }, 
        {
            "location": "/appendix/doc/#_1", 
            "text": "英文(官方网站):  https://golang.org/  中文(官方认可的翻译网站):  https://go-zh.org/   注意: 中文网站更新很慢，官网上有的内容在中文网站找不到，因此建议先上英文，有看不懂的时候再参考中文网站   golang官方FAQ  https://golang.org/doc/faq （当对某个概念有疑问或者学习到某个章节时候可以查询卡一下）  go例子（非官方） https://gobyexample.com （上面有很多例子，比如学习json时候可以在上面看下是否有相关例子）", 
            "title": "官方文档"
        }, 
        {
            "location": "/appendix/code/", 
            "text": "关于编码规范及go的一些宗旨理念等\n\n\n英文：\nhttps://golang.org/doc/effective_go.html#names\n\n\n中文：\nhttps://go-zh.org/doc/effective_go.html#名称\n\n\n分行必须有逗号\n\n\n\n\ngolang有一个特点就是如果写一行，在最后一个元素后面可以逗号也可以不逗号，但如果是分行写，就必须有逗号，比如\n\n\nm[Key{\nA\n,\nB\n}] = Value{1,2}\nm[Key{\nA\n,\nB\n}] = Value{\n    1, 2,\n}\n\n\n\n\n注：只有以下这种情况才不需要逗号，如\n\n\nimport (\n    \nfmt\n\n    \nmath\n\n)\n\ntype (\n    MyInt int\n    AAInt int\n)", 
            "title": "2. 编码规范"
        }, 
        {
            "location": "/appendix/code/#_1", 
            "text": "golang有一个特点就是如果写一行，在最后一个元素后面可以逗号也可以不逗号，但如果是分行写，就必须有逗号，比如  m[Key{ A , B }] = Value{1,2}\nm[Key{ A , B }] = Value{\n    1, 2,\n}  注：只有以下这种情况才不需要逗号，如  import (\n     fmt \n     math \n)\n\ntype (\n    MyInt int\n    AAInt int\n)", 
            "title": "分行必须有逗号"
        }, 
        {
            "location": "/appendix/cli_go_get/", 
            "text": "作用\n\n\n\n\n下载依赖包\n\n\n为了描述清楚，此处做几个名词定义（我自己定义的）：\n\n\n当前目录：准备\ngo install\n生成二进制文件的package目录，此处为\n$GOPATH/src/github.com/cyent/repo2/myhello\n（里面有个\nmyhello.go\n文件\nimport \ngithub.com/cyent/repo1/stringutil\n）\n\n\n依赖包：需要用到的包，如\ngithub.com/cyent/repo1/stringutil\n\n\n实验\n\n\n\n\n\n\n\n\n在当前目录下执行\ngo get\n：\n\n\n下载\ngithub.com/cyent/repo1\n到\n$GOPATH/src/github.com/cyent/\n\n\n\n\n注意这里是下载完整的git仓库，即\ngithub.com/cyent/repo1\n仓库，如果\nmyhello.go\n里是import下面路径，比如\ngithub.com/cyent/repo1/stringutil/aaa/aaa.go\n，也是下载完整的git仓库。因为git仓库没有办法获得其中某个文件，只能一整个仓库载下来。暂时不知道能否支持svn、http目录、ftp等\n\n\n\n\ngo install github.com/cyent/repo1/stringutil\n\n\ngo install github.com/cyent/repo2/myhello\n\n\n\n\n\n\n在当前目录下执行\ngo get github.com/cyent/repo1/stringutil\n：\n\n\n下载\ngithub.com/cyent/repo1\n到\n$GOPATH/src/github.com/cyent/\n\n\ngo install github.com/cyent/repo1/stringutil\n\n\n\n\n\n\n在任意路径下执行\ngo get github.com/cyent/repo1/stringutil\n：\n\n\n下载\ngithub.com/cyent/repo1\n到\n$GOPATH/src/github.com/cyent/\n\n\ngo install github.com/cyent/repo1/stringutil\n\n\n\n\n\n\n在任意路径下执行\ngo get github.com/cyent/repo2/myhello\n（假设\ngithub.com/cyent/repo2\n本地目录已经存在）：\n\n\n下载\ngithub.com/cyent/repo1\n到\n$GOPATH/src/github.com/cyent/\n\n\ngo install github.com/cyent/repo1/stringutil\n\n\ngo install github.com/cyent/repo2/myhello\n\n\n\n\n\n\n在任意路径下执行\ngo get github.com/cyent/repo2/myhello\n（假设\ngithub.com/cyent/repo2\n本地目录不存在）：\n\n\n下载\ngithub.com/cyent/repo2\n到\n$GOPATH/src/github.com/cyent\n\n\n下载\ngithub.com/cyent/repo1\n到\n$GOPATH/src/github.com/cyent\n\n\ngo install github.com/cyent/repo1/stringutil\n\n\ngo install github.com/cyent/repo2/myhello\n\n\n\n\n\n\n实验结论\n\n\n\n\ngo get：\n\n\n\n\n\n\n判断指定路径（这里的路径指go get /path/to）在本地是否存在：\n如果存在，就读取import，然后下载依赖包\n如果不存在，就从远程下载包，然后再读取下载的包里的import来判断是否迭代下载依赖包。\n\n\n\n\n\n\n依赖包都下载完毕后判断go get是否有带-d参数，如果没有-d，则从迭代的最后一个依赖包开始往前一个个install，直到指定路径（这里的路径指go get /path/to）install完毕\n\n\n\n\n\n\ngo get参数：\n\n\n\n\n\n\n\n\n参数\n\n\n说明\n\n\n\n\n\n\n\n\n\n\n-d\n\n\n只下载依赖包，不安装。注意，虽然不安装，但是依然会检测目录下是否有可编译文件，如果没有会报错no buildable Go source files in ...（并不影响下载，也不会安装）\n\n\n\n\n\n\n-f\n\n\n强制不检查每个包，适用于local fork of the original，具体使用不了解\n\n\n\n\n\n\n-fix\n\n\n尚未研究\n\n\n\n\n\n\n-insecure\n\n\n用于http等不安全的远程地址\n\n\n\n\n\n\n-t\n\n\n下载和测试\n\n\n\n\n\n\n-u\n\n\n重新下载依赖包，即使本地workspace已经存在。因为默认情况下如果本地已经存在了就不会再下载了\n\n\n\n\n\n\n-v\n\n\nverbose\n\n\n\n\n\n\n\n\n最佳实践\n\n\n\n\n如果只想下载依赖包，不想做install，则：go get -d -v /path/to\n下载依赖包，并对依赖包做install：go get -v /path/to\n（如果不加/path/to，则需要先cd进入当前目录，当然如果当前目录在本地上就没有存在就还是要加/path/to）\n\n\n下载成功后再手动install当前包：go install -v（如果原来已经存在bin/二进制文件，会自动判断和原来的是否一致，如果一致不会自动编译，如果有更改，会重新编译。即对这个命令不用操心）\n\n\n如果网络不好，比如需要翻墙才能下载，则只能人工去下载，然后放到指定路径下了", 
            "title": "3.1. go get"
        }, 
        {
            "location": "/appendix/cli_go_get/#_1", 
            "text": "下载依赖包  为了描述清楚，此处做几个名词定义（我自己定义的）：  当前目录：准备 go install 生成二进制文件的package目录，此处为 $GOPATH/src/github.com/cyent/repo2/myhello （里面有个 myhello.go 文件 import  github.com/cyent/repo1/stringutil ）  依赖包：需要用到的包，如 github.com/cyent/repo1/stringutil", 
            "title": "作用"
        }, 
        {
            "location": "/appendix/cli_go_get/#_2", 
            "text": "在当前目录下执行 go get ：  下载 github.com/cyent/repo1 到 $GOPATH/src/github.com/cyent/   注意这里是下载完整的git仓库，即 github.com/cyent/repo1 仓库，如果 myhello.go 里是import下面路径，比如 github.com/cyent/repo1/stringutil/aaa/aaa.go ，也是下载完整的git仓库。因为git仓库没有办法获得其中某个文件，只能一整个仓库载下来。暂时不知道能否支持svn、http目录、ftp等   go install github.com/cyent/repo1/stringutil  go install github.com/cyent/repo2/myhello    在当前目录下执行 go get github.com/cyent/repo1/stringutil ：  下载 github.com/cyent/repo1 到 $GOPATH/src/github.com/cyent/  go install github.com/cyent/repo1/stringutil    在任意路径下执行 go get github.com/cyent/repo1/stringutil ：  下载 github.com/cyent/repo1 到 $GOPATH/src/github.com/cyent/  go install github.com/cyent/repo1/stringutil    在任意路径下执行 go get github.com/cyent/repo2/myhello （假设 github.com/cyent/repo2 本地目录已经存在）：  下载 github.com/cyent/repo1 到 $GOPATH/src/github.com/cyent/  go install github.com/cyent/repo1/stringutil  go install github.com/cyent/repo2/myhello    在任意路径下执行 go get github.com/cyent/repo2/myhello （假设 github.com/cyent/repo2 本地目录不存在）：  下载 github.com/cyent/repo2 到 $GOPATH/src/github.com/cyent  下载 github.com/cyent/repo1 到 $GOPATH/src/github.com/cyent  go install github.com/cyent/repo1/stringutil  go install github.com/cyent/repo2/myhello", 
            "title": "实验"
        }, 
        {
            "location": "/appendix/cli_go_get/#_3", 
            "text": "go get：    判断指定路径（这里的路径指go get /path/to）在本地是否存在：\n如果存在，就读取import，然后下载依赖包\n如果不存在，就从远程下载包，然后再读取下载的包里的import来判断是否迭代下载依赖包。    依赖包都下载完毕后判断go get是否有带-d参数，如果没有-d，则从迭代的最后一个依赖包开始往前一个个install，直到指定路径（这里的路径指go get /path/to）install完毕    go get参数：     参数  说明      -d  只下载依赖包，不安装。注意，虽然不安装，但是依然会检测目录下是否有可编译文件，如果没有会报错no buildable Go source files in ...（并不影响下载，也不会安装）    -f  强制不检查每个包，适用于local fork of the original，具体使用不了解    -fix  尚未研究    -insecure  用于http等不安全的远程地址    -t  下载和测试    -u  重新下载依赖包，即使本地workspace已经存在。因为默认情况下如果本地已经存在了就不会再下载了    -v  verbose", 
            "title": "实验结论"
        }, 
        {
            "location": "/appendix/cli_go_get/#_4", 
            "text": "如果只想下载依赖包，不想做install，则：go get -d -v /path/to\n下载依赖包，并对依赖包做install：go get -v /path/to\n（如果不加/path/to，则需要先cd进入当前目录，当然如果当前目录在本地上就没有存在就还是要加/path/to）  下载成功后再手动install当前包：go install -v（如果原来已经存在bin/二进制文件，会自动判断和原来的是否一致，如果一致不会自动编译，如果有更改，会重新编译。即对这个命令不用操心）  如果网络不好，比如需要翻墙才能下载，则只能人工去下载，然后放到指定路径下了", 
            "title": "最佳实践"
        }
    ]
}