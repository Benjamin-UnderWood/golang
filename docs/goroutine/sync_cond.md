## **用途**

---

与互斥量不同，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥量组合使用。互斥量为共享数据的访问提供互斥支持，而条件变量可以就共享数据的状态的变化向相关线程发出通知。

## **声明**

---

```text
lock := new(sync.Mutex)
cond := sync.NewCond(lock)
```

也可以写成一行

```text
cond := sync.NewCond(new(sync.Mutex))
```

## **方法**

---

```
cond.L.Lock()
cond.L.Unlock()
cond.Wait()
cond.Signal()
cond.Broadcast()
```

!!! note
	- `cond.L.Lock()`和`cond.L.Unlock()`：也可以使用`lock.Lock()`和`lock.Unlock()`，完全一样，因为是指针转递

	- `cond.Wait()`：Unlock()->***阻塞等待通知(即等待Signal()或Broadcast()的通知)->收到通知***->Lock()

	- `cond.Signal()`：通知一个Wait()了的，若没有Wait()，也不会报错。**Signal()通知的顺序是根据原来加入通知列表(Wait())的先入先出**

	- `cond.Broadcast()`: 通知所有Wait()了的，若没有Wait()，也不会报错

## **工作原理(摘取)**

---

下面图1-图3来自"郝林"的go语言书籍

没用条件变量时候:

![](/img/cond_1.png)

图1：生产者线程添加数据库的流程

图1存在一个问题：当队列总是满的时候，就会不停的循环获取队列状态，因此也不会释放锁，而消费者就无法获得锁来取走队列中的数据。如果队列中的数据无法取走，那么队列就永远都是满的，导致了死锁。

使用条件变量后，解决了这个问题：

![](/img/cond_2.png)

图2：生产者线程添加数据库的流程

图2解决了图1的问题：当队列满的时候，则先解锁，这样就不会死锁（释放锁给其他人用）

附：和图2匹配的消费者线程

![](/img/cond_3.png)

图3：消费者线程

## **工作原理(原创)**

---

![](/img/cond_4.png)

## **条件变量和sync.Cond关系**

---

**以下均为个人理解（不一定准确）**

条件变量是一种应用场景，不是只有golang才有条件变量，其他操作系统、语言也都有条件变量

sync.Cond是golang为了适配这种应用场景而开发出来的配套组件。准确说是通过sync.Cond配合sync.Mutex来实现条件变量的应用场景。

因此，sync.Cond本身并不是什么条件变量，只是它的方法可以让你实现条件变量的应用，所以干脆名字就叫条件变量。也就是说，完全可以不用于条件变量而用于其他环境，只是没人这么干而已，而且也不是初衷。

## **不能并发**

---

条件变量只是解决了互斥量的问题，或者说配合互斥量解决了锁的问题，但是并不能实现并发，就是说消费者和生产者都各只能有1个，如果超过1个，则会发生非预期的锁抢占问题。

因为不知道锁什么时候被非预期的协程给抢占了，导致死锁或非预期的情况发生。
