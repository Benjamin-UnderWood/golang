## **关于堆和栈的基础**

---

下面内容摘自 http://blog.cyeam.com/golang/2017/02/08/go-optimize-slice-pool

程序会从操作系统申请一块内存，而这块内存也会被分成堆和栈。栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。

```go
func F() {
    temp := make([]int, 0, 20)
    ...
}
```

类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。**申请到栈内存好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。**

```go
func F() []int{
    a := make([]int, 0, 20)
    return a
}
```

而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到堆上面了。**申请到堆上面的内存才会引起垃圾回收。**

```go
func F() {
    a := make([]int, 0, 20)
    b := make([]int, 0, 20000)
    l := 20
    c := make([]int, 0, l)
}
```

a和b代码一样，就是申请的空间不一样大，但是它们两个的命运是截然相反的。a前面已经介绍过，会申请到栈上面，而b，由于申请的内存较大，**编译器会把这种申请内存较大的变量转移到堆上面。即使是临时变量，申请过大也会在堆上面申请。**

而c，对我们而言其含义和a是一致的，**但是编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。**

实际项目基本都是通过c := make([]int, 0, l)来申请内存，长度都是不确定的。自然而然这些变量都会申请到堆上面了。Golang使用的垃圾回收算法是『标记——清除』。简单得说，就是程序要从操作系统申请一块比较大的内存，内存分成小块，通过链表链接。每次程序申请内存，就从链表上面遍历每一小块，找到符合的就返回其地址，没有合适的就从操作系统再申请。如果申请内存次数较多，而且申请的大小不固定，就会引起内存碎片化的问题。申请的堆内存并没有用完，但是用户申请的内存的时候却没有合适的空间提供。这样会遍历整个链表，还会继续向操作系统申请内存。这就能解释我一开始描述的问题，**申请一块内存变成了慢语句。**

**申请内存变成了慢语句，解决方法就是使用临时对象池**
