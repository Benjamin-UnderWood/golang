1. 在包级别定义的变量，是全局变量，即在main函数里对这个变量做的修改，或者在其他函数里对这个变量做的修改，都是真实改了这个变量的值

2. 在函数里（包括main函数或其他函数）定义的变量，只在自己函数里有效，若在其他函数里对这个变量做修改，会提示undefined

3. 可以存在变量名相同，但作用域不同的多个变量。（个人觉得太晦涩，不建议这么用）

4. 函数内部的函数（即函数值），有前后顺序要求

??? note "例1. 包级别的变量能否被函数引用?"
	```go
	var A int = 1
	func foo() {
	    fmt.Println(A)
	}
	func main() {
	    foo()
	}
	```

	输出

	```text
	1
	```

	答: 包级别的变量可以被函数引用

??? note "例2. 包级别的函数是否有顺序要求?"
	```go
	var A int = 1
	func main() {
	    foo()
	}
	func foo() {
	    fmt.Println(A)
	}
	```

	输出

	```text
	1
	```

	答: 包级别的函数没有顺序要求

??? note "例3. 一个函数里的变量能否被包级别的另一个函数引用?"
	```go
	func foo() {
	    fmt.Println(A)
	}
	func main() {
	    var A int = 1
	    foo()
	}
	```

	报错

	```text
	undefined: A
	```

	答: 一个函数里的变量不能被包级别的另一个函数引用

??? note "例4. 一个函数里的变量能否被内嵌的函数值引用?"
	```go
	func main() {
	    var A int = 1
	    foo := func () {
	        fmt.Println(A)
	    }
	    foo()
	}
	```

	输出

	```text
	1
	```

	答: 一个函数里的变量可以被内嵌的函数值引用

??? note "例5. 函数值是否有顺序要求?"
	```go
	func main() {
	    foo := func () {
	        fmt.Println(A)
	    }
	    var A int = 1
	    foo()
	}
	```

	报错

	```text
	undefined: A
	```

	答: 函数值有顺序要求

??? note "例6. 包级别的变量能否在函数内部的函数值里引用?"

	```go
	var A int = 1
	func main() {
	    foo := func () {
	        A = 2
	    }
	    foo()
	    fmt.Println(A)
	}
	```

	输出

	```text
	2
	```

	答: 包级别的变量可以在函数内部的函数值里引用

??? note "例7. 函数值嵌套函数值，还能否引用外部变量?"
	```go
	func main() {
	    A := 1
	    foo := func () {
	        bar := func () {
	            A = 2
	        }
	        bar()
	    }
	    foo()
	    fmt.Println(A)
	}
	```

	输出

	```text
	2
	```

	答: 函数值嵌套函数值，可以引用外部变量

??? note "例8. 是否可以存在不同作用域，但名字相同的变量(本例十分经典)?"
	```go
	func main() {
	    A := 1
	    foo := func () {
	        A = 2
	        A := 3
	        A = 4
	        fmt.Println(A)
	    }
	    foo()
	    fmt.Println(A)
	}
	```

	输出

	```text
	4
	2
	```

	答: 可以存在不同作用域，但名字相同的变量

??? note "例9. 本例与例8相似，若一开始就声明同名的变量名，那么还能否引用外部同名变量?"
	```go
	func main() {
	    A := 1
	    foo := func () {
	        A := 3
	        A = 2
	        fmt.Println(A)
	    }
	    foo()
	    fmt.Println(A)
	}
	```

	输出

	```text
	2
	1
	```

	答: 若一开始就声明同名的变量名，则无法再引用外部同名变量

例子总结:

1. 例1-例7：包级别的函数，写上面或写下面都一样（包括和引用的变量，以及被引用的上层函数，比如变量A的声明写在foo函数声明后，或者foo函数写在main函数上面或者下面），而写在函数里（比如main函数）里的函数（函数值），则和顺序有关，比如在函数值里面引用的变量如果是在这个函数值上面声明的，则可以引用，如果是在函数值下面声明的则提示undefined

2. 例8-例9：可以看到如果在函数内部声明一个函数外部已经存在的变量，则在函数内部，这个变量和函数的变量只是名字相同，但实际是2个变量

3. 例3-例4：可以看到把函数放到包级别比较好，因为main函数里声明的变量无法直接被这个函数里引用，即安全性提高了，不容易误操作

**关于for、if等带有代码块的作用域，详见各自章节**:

1. [for作用域](/syntax/for/#_4)

2. [if作用域](/syntax/if/#_3)

3. [switch作用域](/syntax/switch/#_4)

