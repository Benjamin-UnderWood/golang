## **内置的testing模块**

---

go内置一个轻量级测试框架，使用方法：

1. 文件以`_test.go`结尾

2. `import "testing"`

3. 函数名为`TestXXX`，并且parameter为`t *testing.T`

例子：

在`$GOPATH/src/github.com/cyent/golang/example/stringutil`里新建文件`reverse_test.go`

```go
package stringutil

import "testing"

func TestReverse(t *testing.T) {
	cases := []struct {
		in, want string
	}{
		{"Hello, world", "dlrow ,olleH"},
		{"Hello, 世界", "界世 ,olleH"},
		{"", ""},
	}
	for _, c := range cases {
		got := Reverse(c.in)
		if got != c.want {
			t.Errorf("Reverse(%q) == %q, want %q", c.in, got, c.want)
		}
	}
}
```

执行测试：

```text
go test github.com/cyent/golang/exmaple/stringutil
```

或者在`$GOPATH/src/github.com/cyent/golang/exmaple/stringutil`目录下执行`go test`

输出

```text
ok  	github.com/cyent/golang/example/stringutil	0.006s
```

表示测试通过

如果是在stringutil目录下直接执行`go test`，会输出

```text
PASS
ok  	github.com/cyent/golang/example/stringutil	0.005s
```

!!! note ""
	推荐使用`go test -v`，输出更详细

## **我对单元测试的理解**

---

**我也是第一次接触单元测试，所以我的理解也许不是对的**

首先，我是在百度百科里看到的[单元测试](https://baike.baidu.com/item/单元测试)，其中有几段话受益匪浅:

> 什么时候测试？单元测试越早越好，早到什么程度？极限编程(Extreme Programming,或简称XP)讲究TDD，即测试驱动开发，先编写测试代码，再进行开发。在实际的工作中，可以不必过分强调先什么后什么，重要的是高效和感觉舒适。从经验来看，{==先编写产品函数的框架，然后编写测试函数，针对产品函数的功能编写测试用例，然后编写产品函数的代码，每写一个功能点都运行测试，随时补充测试用例==}。所谓先编写产品函数的框架，是指先编写函数空的实现，有返回值的直接返回一个合适值，编译通过后再编写测试代码，这时，函数名、参数表、返回类型都应该确定下来了，所编写的测试代码以后需修改的可能性比较小。

> 这是那些没有首先为每个单元编写一个详细的规格说明而直接跳到编码阶段的开发人员提出的一条普遍的抱怨，{==当编码完成以后并且面临代码测试任务的时候，他们就阅读这些代码并找出它实际上做了什么，把他们的测试工作基于已经写好的代码的基础上==}。当然，他们无法证明任何事情。所有的这些测试工作能够表明的事情就是编译器工作正常。是的，他们也许能够抓住（希望能够）罕见的编译器Bug，但是他们能够做的仅仅是这些。
如果他们首先写好一个详细的规格说明，测试能够以规格说明为基础。代码就能够针对它的规格说明，而不是针对自身进行测试。这样的测试仍然能够抓住编译器的Bug，同时也能找到更多的编码错误，甚至是一些规格说明中的错误。{==好的规格说明可以使测试的质量更高，所以最后的结论是高质量的测试需要高质量的规格说明==}。

> 在实践中会出现这样的情况：一个开发人员要面对测试一个单元时只给出单元的代码而没有规格说明这样吃力不讨好的任务。你怎样做才会有更多的收获，而不仅仅是发现编译器的Bug？{==第一步是理解这个单元原本要做什么， --- 不是它实际上做了什么==}。比较有效的方法是倒推出一个概要的规格说明。这个过程的主要输入条件是要阅读那些程序代码和注释， 主要针对这个单元， 及调用它和被它调用的相关代码。{==画出流程图是非常有帮助的==}，你可以用手工或使用某种工具。{==可以组织对这个概要规格说明的走读（Review)，以确保对这个单元的说明没有基本的错误， 有了这种最小程度的代码深层说明，就可以用它来设计单元测试了==}。

`go test`时候会先编译检查一遍，和`go run`、`go install`相同，即只有编译检查通过了才会继续。因此`go test`实际上做了2个测试: 传入参数和数量是否正确（不正确就编译报错），以及业务逻辑是否正确。

关于业务逻辑是否正确，我的理解是：假设被测试函数是做除法，在函数里的逻辑会判断传入的参数是否为0，如果为0，则返回error。那么测试内容就是传入0，看下是否返回error，如果没有返回error，则t.Errorf抛错

总结: 编写单元测试时候，根据预设规则，调用被测试函数，依次传入预设的若干情况，来测试函数的返回是否正确。
