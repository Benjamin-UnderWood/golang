一切事物都是从同步阻塞开始，慢慢发展成异步非阻塞

## **同步、异步**

---

同步、异步是一对，关注的是消息通知机制，一次完成是同步，两次完成是异步

- 同步: 打电话（一次性把事情说完）

- 异步: 发短信说事，等待回复（收到回复才算是把事情说完，这里是两次）

## **阻塞、非阻塞**

---

阻塞、非阻塞是一对，关注的是程序在等待调用结果（消息，返回值）时的状态

- 阻塞: 只能做一件事

- 非阻塞: 做一件事同时可以做其他事

## **同步异步和阻塞非阻塞的组合**

---

同步、异步，与阻塞、非阻塞，没有必然联系

组合例子：

- 同步阻塞: 打电话时候，其他任何事都做不了（比如不能同时看孩子）。效率低下

- 同步非阻塞: 打电话时候，时不时看看孩子有没有危险。不停切换，效率低下

- 异步阻塞: 发短信，在收到短信回复之前什么事都做不了（比如不能同时看孩子）。这种情形不常见

- 异步非阻塞: 发短信，然后陪孩子玩，收到短信回复通知后再去看手机。效率最高

编码应用，指的都是用户代码逻辑，而非底层的实现：

- 同步阻塞：最普遍最常见，符合思维，容易编写，容易调试

- 同步非阻塞：自己的逻辑是同步，但由于使用了某个模块，而这个模块是实现异步的，所以立刻返回，于是从自己的代码逻辑角度看没有阻塞。

	!!! warning ""
		如果底层没有实现异步，那么上层的用户逻辑就不可能实现非阻塞。比如nodejs都说是单线程、异步、非阻塞I/O，其实是因为nodejs底层实现了异步（比如多线程之类的），但没有开放异步功能（比如多线程）给用户使用。

## **单线程、多线程**

---

- 单线程: 单线程只能实现同步，无法实现异步

- 多线程: 是实现异步的最常用手段，实现异步还有多进程、协程等方法

## **多核、多进程、多线程、协程**

---

- 多核:

- 多进程:

- 多线程:

- 协程:

## **并发、并行**

---

- 并发: (宏观的)，逻辑上的同时运行，但同一时间底层可能只有一个任务在运行

- 并行: (微观的)，真正的同时运行，通过多核实现，任务分布在不同核上，也可以是分布在不同服务器上。

单核cpu就是并发，多核cpu才有可能并行，为什么说是有可能而不是绝对，因为系统上运行的程序数量必定比cpu数量多


## **事件驱动、观察者、生产者消费者、订阅发布、服务发现**

---

- 事件驱动: A -> B
