一切事物都是从同步阻塞开始，慢慢发展成异步非阻塞

## **同步、异步**

---

同步、异步是一对，关注的是消息通知机制，一次完成是同步，两次完成是异步

- 同步: 打电话（一次性把事情说完）

- 异步: 发短信说事，等待回复（收到回复才算是把事情说完，这里是两次）

同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。

## **阻塞、非阻塞**

---

阻塞、非阻塞是一对，关注的是程序在等待调用结果（消息，返回值）时的状态

- 阻塞: 只能做一件事

- 非阻塞: 做一件事同时可以做其他事

阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。

阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。

## **同步异步和阻塞非阻塞的组合**

---

同步、异步，与阻塞、非阻塞，没有必然联系

组合例子：

- 同步阻塞: 打电话时候，其他任何事都做不了（比如不能同时看孩子）。效率低下

- 同步非阻塞: 打电话时候，时不时看看孩子有没有危险。不停切换，效率低下

- 异步阻塞: 发短信，在收到短信回复之前什么事都做不了（比如不能同时看孩子）。这种情形不常见

- 异步非阻塞: 发短信，然后陪孩子玩，收到短信回复通知后再去看手机。效率最高

编码应用，指的都是用户代码逻辑，而非底层的实现：

- 同步阻塞：最普遍最常见，符合思维，容易编写，容易调试

- 同步非阻塞：自己的逻辑是同步，但由于使用了某个模块，而这个模块是实现异步的，所以立刻返回，于是从自己的代码逻辑角度看没有阻塞。

	!!! warning ""
		如果底层没有实现异步，那么上层的用户逻辑就不可能实现非阻塞。比如nodejs都说是单线程、异步、非阻塞I/O，其实是因为nodejs底层实现了异步（比如多线程之类的），但没有开放异步功能（比如多线程）给用户使用。

## **单线程、多线程**

---

- 单线程: 单线程只能实现同步，无法实现异步

- 多线程: 是实现异步的最常用手段，实现异步还有多进程、协程等方法

## **多进程、多线程、协程**

---

- 多进程:

- 多线程:

- 协程: 协程在经典的web应用场景就是推送的并发能力

如果说多进程对于多CPU，多线程对应多核CPU，那么事件驱动和协程则是在充分挖掘不断提高性能的单核CPU的潜力。

无论是线程还是进程，使用的都是同步进制，当发生阻塞时，性能会大幅度降低，无法充分利用CPU潜力，浪费硬件投资，更重要造成软件模块的铁板化，紧耦合，无法切割，不利于日后扩展和变化。不管是进程还是线程，每次阻塞、切换都需要陷入系统调用(system call)，先让CPU跑操作系统的调度程序，然后再由调度程序决定该跑哪一个进程(线程)。多个线程之间在一些访问互斥的代码时还需要加上锁，这也是导致多线程编程难的原因之一。

现下流行的异步server都是基于事件驱动的（如nginx）。事件驱动简化了编程模型，很好地解决了多线程难于编程，难于调试的问题。异步事件驱动模型中，把会导致阻塞的操作转化为一个异步操作，主线程负责发起这个异步操作，并处理这个异步操作的结果。由于所有阻塞的操作都转化为异步操作，理论上主线程的大部分时间都是在处理实际的计算任务，少了多线程的调度时间，所以这种模型的性能通常会比较好。

总的说来，当单核cpu性能提升，cpu不在成为性能瓶颈时，采用异步server能够简化编程模型，也能提高IO密集型应用的性能。

## **并发、并行**

---

- 并发: (宏观的)，逻辑上的同时运行，但同一时间底层可能只有一个任务在运行

- 并行: (微观的)，真正的同时运行，通过多核实现，任务分布在不同核上，也可以是分布在不同服务器上。

单核cpu就是并发，多核cpu才有可能并行，为什么说是有可能而不是绝对，因为系统上运行的程序数量必定比cpu数量多


## **事件驱动、观察者、生产者消费者、订阅发布、服务发现**

---

- 事件驱动:

- 观察者:

- 生产消费者模式: 指的是由生产者将数据源源不断推送到消息中心，由不同的消费者从消息中心取出数据做自己的处理，在同一类别下，所有消费者拿到的都是同样的数据

- 订阅发布模式: 本质上也是一种生产消费者模式，不同的是，由订阅者首先向消息中心指定自己对哪些数据感兴趣，发布者推送的数据经过消息中心后，每个订阅者拿到的仅仅是自己感兴趣的一组数据。

- 服务注册与发现:

生产消费者模式和订阅发布模式是使用消息中间件时最常用的，用于功能解耦和分布式系统间的消息通信。
